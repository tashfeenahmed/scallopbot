---
phase: 23-e2e-websocket-testing
plan: 01
type: execute
---

<objective>
Create E2E test harness that boots a real Gateway with controlled mock LLM providers, connects via WebSocket, and validates the basic message flow end-to-end.

Purpose: Establish reusable test infrastructure so subsequent plans can write focused feature tests without duplicating setup/teardown boilerplate.
Output: Working E2E test file with gateway lifecycle helpers, WebSocket client wrapper, and baseline conversation test.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase summaries (v3.0 memory subsystem):
@.planning/phases/18-retrieval-reranking/18-02-SUMMARY.md
@.planning/phases/22-behavioral-profiling/22-02-SUMMARY.md

# Key source files:
@src/gateway/gateway.ts
@src/channels/api.ts
@src/channels/api.test.ts
@src/config/config.ts
@src/memory/scallop.test.ts
@src/providers/types.ts

# Codebase docs:
@.planning/codebase/TESTING.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/STACK.md

**Tech stack available:** Vitest, better-sqlite3, ws, pino
**Established patterns:** co-located test files, vi.mock() for modules, factory functions for mocks, silent pino logger for tests, /tmp/ for test databases
**Constraining decisions:**
- [Phase 18]: Opt-in rerankProvider via constructor — existing behavior unchanged without it
- [Phase 19]: Optional classifierProvider for RelationGraph — regex fallback when absent
- [Phase 20]: Opt-in ActivationConfig via ScallopMemoryStoreOptions constructor
- [Phase 21]: Opt-in fusionProvider in BackgroundGardener
- [Phase 22]: Optional sessions/messageEmbeddings params for backward-compatible signal computation
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create E2E test helpers and gateway bootstrap</name>
  <files>src/e2e/helpers.ts, src/e2e/e2e.test.ts</files>
  <action>
Create `src/e2e/` directory for E2E tests (separate from unit tests to allow different run configurations).

**src/e2e/helpers.ts** — Reusable test infrastructure:

1. `createMockLLMProvider(responses: string[])` — Returns an LLMProvider that cycles through predefined response strings. Must implement the complete() method returning CompletionResponse with tokenUsage. Track call count for assertions.

2. `createMockEmbeddingProvider()` — Returns an EmbeddingProvider that generates deterministic pseudo-embeddings (e.g., hash content string to produce a consistent 384-dim vector). This enables semantic search without Ollama. Use a simple hash-based approach: convert characters to numbers, normalize to unit vector.

3. `createE2EGateway(options?: { port?: number, dbPath?: string })` — Instantiate a real Gateway with:
   - A real Config object (use sensible test defaults: random port 4000-5000, /tmp/ database, API channel enabled, Telegram disabled)
   - Mock providers registered in ProviderRegistry
   - Return { gateway, port, dbPath } for test access

   **Important:** The Gateway class initializes everything internally. We need to either:
   - Construct a Config that the Gateway accepts (study config.ts Zod schema for required fields)
   - Or if Gateway is too coupled, create a lighter "test gateway" that wires components directly

   Study how gateway.ts initialize() works to determine the minimal config needed. The goal is a real gateway with real SQLite, real memory store, real agent loop — but mock LLM providers instead of real API calls.

4. `createWsClient(port: number)` — Returns a promise-based WebSocket client wrapper with:
   - `connect()`: opens connection, waits for 'open' event
   - `send(msg: WsMessage)`: sends JSON message
   - `waitForResponse(type?: string, timeout?: number)`: collects messages until response type seen or timeout
   - `collectAll(timeout?: number)`: collects all messages until timeout
   - `close()`: clean disconnect

   Use the `ws` library (already a project dependency).

5. `cleanupE2E(gateway, dbPath)` — Stop gateway, delete test database files.

**Key challenge:** Gateway.initialize() reads Config and creates providers internally. Study the Config Zod schema to understand what env vars or config shape is needed. The mock providers need to be injected somehow — either by setting env vars that cause provider initialization to succeed with mocks, or by using a pattern where we construct the gateway components ourselves and wire them.

Look at gateway.test.ts for any patterns already established for testing the gateway.

Avoid: Creating a whole new server class. Work with the existing Gateway if possible, or if Gateway is too tightly coupled to real providers, create a minimal test setup that wires ApiChannel + Agent + SessionManager + ScallopMemoryStore directly (similar to how api.test.ts mocks these, but using REAL implementations).
  </action>
  <verify>npx vitest run src/e2e/helpers.ts --passWithNoTests (file compiles without errors)</verify>
  <done>helpers.ts exports createMockLLMProvider, createMockEmbeddingProvider, createE2EGateway or equivalent bootstrap, createWsClient, cleanupE2E — all compile cleanly</done>
</task>

<task type="auto">
  <name>Task 2: Baseline E2E conversation test</name>
  <files>src/e2e/e2e.test.ts</files>
  <action>
Using the helpers from Task 1, write baseline E2E tests:

1. **Test: WebSocket connect and ping/pong** — Connect to running gateway, send `{ type: 'ping' }`, assert response `{ type: 'pong' }`.

2. **Test: Send chat message and receive response** — Send `{ type: 'chat', message: 'Hello', sessionId: 'e2e-test-1' }`. Collect all WS messages. Assert:
   - At least one `{ type: 'response' }` message received
   - Response has non-empty content
   - SessionId matches

3. **Test: Memory storage after conversation** — Send a message with a memorable fact (e.g., "My name is Alice and I live in Tokyo"). Wait for response. Then query the test database directly via ScallopDatabase to verify:
   - A memory was created for the user
   - Memory content relates to the stated fact
   - Memory has category 'fact' or appropriate type

4. **Test: Memory retrieval in follow-up** — After storing a fact, send a follow-up message asking about it (e.g., "Where do I live?"). Collect messages. Assert:
   - A `{ type: 'memory' }` progress message was received (indicating memory search happened)
   - The response references the previously stored fact

**Test lifecycle:**
- `beforeAll`: Boot gateway with createE2EGateway(), wait for ready
- `afterAll`: cleanupE2E() — stop gateway, delete test DB
- `beforeEach`: Create fresh WS client
- `afterEach`: Close WS client

**Mock LLM behavior:** The mock provider needs to return responses that:
- Include skill invocations when appropriate (the agent expects to see [DONE] markers)
- For fact extraction: return structured fact JSON when the fact extractor calls the LLM
- Keep it simple: return a canned response that includes [DONE] so the agent loop terminates

Study how the agent loop works (agent.ts processMessage) to understand what LLM response format the agent expects. The mock provider's complete() output must match what the agent parses.

Set test timeout to 30s (E2E tests are slower than unit tests).

Avoid: Flaky timing — use explicit waitForResponse with generous timeouts rather than fixed delays. Avoid testing LLM quality — we're testing the pipeline, not the model.
  </action>
  <verify>npx vitest run src/e2e/e2e.test.ts (all 4 tests pass)</verify>
  <done>4 baseline E2E tests pass: ping/pong, chat response, memory storage, memory retrieval. Gateway boots and shuts down cleanly in test lifecycle.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx vitest run src/e2e/` passes all tests
- [ ] No TypeScript compilation errors
- [ ] Gateway starts and stops cleanly (no port conflicts, no leftover processes)
- [ ] Test database is cleaned up after tests
- [ ] Tests complete within 60s total
</verification>

<success_criteria>

- E2E test harness created with reusable helpers
- Gateway boots with mock providers (no real API calls)
- WebSocket client wrapper works for send/receive
- 4 baseline tests pass proving the pipeline works end-to-end
- Infrastructure ready for feature-specific tests in Plan 02 and 03
</success_criteria>

<output>
After completion, create `.planning/phases/23-e2e-websocket-testing/23-01-SUMMARY.md`
</output>
