---
phase: 23-e2e-websocket-testing
plan: 02
type: execute
---

<objective>
Validate v3.0 memory intelligence features (re-ranking, LLM relations, spreading activation) end-to-end via WebSocket conversations that trigger each feature and verify DB state.

Purpose: Prove that re-ranking improves search ordering, LLM-classified relations are stored correctly, and spreading activation retrieves related memories — all through the real pipeline, not mocked units.
Output: E2E tests covering the memory intelligence pipeline with DB-level assertions.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan in this phase:
@.planning/phases/23-e2e-websocket-testing/23-01-SUMMARY.md

# v3.0 feature summaries:
@.planning/phases/18-retrieval-reranking/18-01-SUMMARY.md
@.planning/phases/18-retrieval-reranking/18-02-SUMMARY.md
@.planning/phases/19-llm-guided-relations/19-01-SUMMARY.md
@.planning/phases/19-llm-guided-relations/19-02-SUMMARY.md
@.planning/phases/20-spreading-activation/20-01-SUMMARY.md
@.planning/phases/20-spreading-activation/20-02-SUMMARY.md

# Key source files:
@src/e2e/helpers.ts
@src/e2e/e2e.test.ts
@src/memory/scallop-store.ts
@src/memory/reranker.ts
@src/memory/relations.ts
@src/memory/db.ts

**Tech stack available:** Vitest, better-sqlite3, ws
**Established patterns:** E2E helpers from 23-01, createMockLLMProvider, createWsClient, direct DB assertions
**Constraining decisions:**
- [Phase 18]: Re-rank after limit slice, score blending original*0.4 + LLM*0.6, drop results < 0.05
- [Phase 19]: classifyRelation with batch support, regex fallback when no provider
- [Phase 20]: spreadActivation with typed edge weights, 3-step max, 0.5 decay/hop, noise sigma=0.2
</context>

<tasks>

<task type="auto">
  <name>Task 1: Re-ranking E2E test</name>
  <files>src/e2e/memory-intelligence.test.ts</files>
  <action>
Create a new E2E test file for memory intelligence features. Uses helpers from 23-01.

**Test: Re-ranking reorders search results by relevance**

Setup:
- Boot gateway with mock LLM provider that returns controlled re-rank scores. The rerankProvider receives candidates and must return scores. Configure the mock to return high scores for semantically relevant candidates and low scores for irrelevant ones.
- Seed the test database with 5+ memories of varying relevance to a test query. Use the ScallopDatabase directly to insert memories with embeddings (use the mock embedding provider to generate consistent embeddings).
  - Memory A: "User loves Italian food" (highly relevant to "food preferences")
  - Memory B: "User works at a bank" (irrelevant to food)
  - Memory C: "User's favorite restaurant is Olive Garden" (highly relevant)
  - Memory D: "User drives a Toyota" (irrelevant)
  - Memory E: "User is allergic to shellfish" (somewhat relevant)

Test:
- Send a chat message: "What are my food preferences?"
- The agent will search memory, which triggers re-ranking
- Collect the `{ type: 'memory' }` progress message to see what was retrieved
- Query DB to check access counts were updated (re-ranked results get access recorded)
- Assert that memory items in the response relate to food (A, C, E should appear before B, D)

**Key:** The mock rerankProvider must be wired into the gateway's ScallopMemoryStore. Study how 23-01 helpers bootstrap the gateway — the mock provider for re-ranking needs to be passed as rerankProvider option.

If direct memory seeding is needed before the test, access the ScallopMemoryStore or ScallopDatabase from the gateway (may need to expose it from helpers or access it via the test dbPath).

Avoid: Testing exact score values (those are unit test concerns). Focus on ordering — relevant results should rank higher.
  </action>
  <verify>npx vitest run src/e2e/memory-intelligence.test.ts -t "re-ranking" (test passes)</verify>
  <done>Re-ranking E2E test passes: seeded memories are re-ordered by relevance when searched via WebSocket conversation.</done>
</task>

<task type="auto">
  <name>Task 2: LLM relations and spreading activation E2E tests</name>
  <files>src/e2e/memory-intelligence.test.ts</files>
  <action>
Add two more E2E tests to the memory-intelligence test file:

**Test: LLM-classified relations stored after fact extraction**

Setup:
- Configure mock LLM provider to return fact extraction responses that include related facts. When the LLMFactExtractor calls the provider, it should return structured facts.
- Send two related messages via WebSocket:
  1. "I just got a new job at Google as a software engineer"
  2. "My salary at Google is $200k"

After both messages are processed:
- Query the `memory_relations` table in the test DB
- Assert that a relation exists between the job memory and salary memory
- Assert the relation type is appropriate (EXTENDS or UPDATES)
- If classifierProvider is configured, verify the relation was LLM-classified (not just regex)

**Test: Spreading activation retrieves related memories**

Setup:
- Seed the test DB with a cluster of related memories connected by relations:
  - Memory X: "User lives in San Francisco"
  - Memory Y: "User's apartment is in Mission District" (EXTENDS from X)
  - Memory Z: "User pays $3000 rent" (EXTENDS from Y)
  - Insert relations manually via ScallopDatabase
- If spreading activation is configured (ActivationConfig passed to store), searching for "San Francisco" should activate Y and Z through the relation graph

Test:
- Send a chat message that triggers memory search: "Tell me about my living situation"
- Collect the `{ type: 'memory' }` progress message
- Assert that related memories (apartment, rent) appear in results even if they didn't directly match the query text
- Or: query DB to check that access counts were updated for spreading-activated memories

**Key:** Spreading activation is opt-in via ActivationConfig. The E2E gateway setup needs to pass this config. Study how gateway.ts passes ActivationConfig to ScallopMemoryStore — the E2E helpers may need to be extended.

Avoid: Testing activation score math (that's unit tested in 20-01). Focus on: does the pipeline retrieve related memories that wouldn't be found by keyword/semantic search alone?
  </action>
  <verify>npx vitest run src/e2e/memory-intelligence.test.ts (all 3 tests pass)</verify>
  <done>3 E2E tests pass: re-ranking reorders results, LLM relations stored between related facts, spreading activation retrieves connected memories.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx vitest run src/e2e/memory-intelligence.test.ts` passes all tests
- [ ] No TypeScript compilation errors
- [ ] Tests seed and query the DB correctly
- [ ] Test DB cleaned up after each run
- [ ] Tests complete within 60s total
</verification>

<success_criteria>

- Re-ranking verified: relevant memories rank higher in E2E search
- LLM relations verified: related facts get classified relations in DB
- Spreading activation verified: related memories retrieved through graph traversal
- All tests use real pipeline (no mocking of memory subsystem internals)
</success_criteria>

<output>
After completion, create `.planning/phases/23-e2e-websocket-testing/23-02-SUMMARY.md`
</output>
