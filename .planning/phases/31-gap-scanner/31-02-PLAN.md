---
phase: 31-gap-scanner
plan: 02
type: tdd
---

<objective>
Build the Stage 2 LLM gap diagnosis module — prompt builder and response parser that takes GapSignal[] from Stage 1 and produces DiagnosedGap[] via a single LLM triage call.

Purpose: LLM adds human judgment to raw heuristic signals — filtering noise, explaining gaps, and scoring confidence. Single batched call keeps costs minimal.
Output: gap-diagnosis.ts with buildGapDiagnosisPrompt, parseGapDiagnosis, and diagnoseGaps orchestrator, fully tested via TDD.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/tdd.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-gap-scanner/31-RESEARCH.md

# Key source files (established patterns):
@src/memory/reflection.ts
@src/memory/gap-scanner.ts
@src/memory/affect-smoothing.ts

# Prior plan in this phase:
@.planning/phases/31-gap-scanner/31-01-SUMMARY.md

**Tech stack available:** LLM provider via fusionProvider pattern, SmoothedAffect, GapSignal from 31-01
**Established patterns:** buildReflectionPrompt/reflect pattern from reflection.ts, CompletionRequest interface, JSON-only LLM response parsing
**Constraining decisions:**
- Research: Single LLM call for all signals (not per-gap calls)
- Research: "When in doubt, mark as NOT actionable" prompt instruction
- Research: Include proactiveness dial in prompt for LLM calibration
- fusionProvider opt-in pattern (v3.0)
</context>

<feature>
  <name>LLM Gap Diagnosis (Stage 2)</name>
  <files>src/memory/gap-diagnosis.ts, src/memory/gap-diagnosis.test.ts</files>
  <behavior>
    Core types:
    ```
    DiagnosedGap { signal: GapSignal, diagnosis: string, actionable: boolean, suggestedAction: string, confidence: number }
    UserContext { affect: SmoothedAffect | null, dial: 'conservative' | 'moderate' | 'eager', recentTopics: string[] }
    ```

    buildGapDiagnosisPrompt(signals, userContext):
    - Returns CompletionRequest with system prompt containing:
      - Role: proactive personal assistant analyzing signals
      - Rule: "When in doubt, mark as NOT actionable. False silence is better than false alarm."
      - User's proactiveness dial in context
      - User's current mood (emotion from affect or 'unknown')
      - JSON-only response format instruction
    - User message: numbered signal list with type, severity, description
    - temperature: 0.2 (low creativity for triage)
    - maxTokens: 800
    - Empty signals → returns prompt with empty signal list (still valid)

    parseGapDiagnosis(response, signals):
    - Parse JSON {"gaps": [{index, actionable, confidence, diagnosis, suggestedAction}]}
    - Map each parsed gap back to its source GapSignal via index
    - Invalid JSON → return all signals as not-actionable (fail safe)
    - Missing fields → default: actionable=false, confidence=0
    - Index out of range → skip that entry
    - Returns DiagnosedGap[]

    diagnoseGaps(signals, userContext, provider):
    - If signals empty → return []
    - Build prompt → call provider.complete() → extract text → parse response
    - On LLM error → return all signals as not-actionable with confidence 0 (fail safe)
    - Returns DiagnosedGap[]
  </behavior>
  <implementation>
    Create src/memory/gap-diagnosis.ts with:
    - Import GapSignal from gap-scanner.ts
    - Import SmoothedAffect from affect-smoothing.ts (import type)
    - Export DiagnosedGap, UserContext interfaces
    - Export buildGapDiagnosisPrompt as pure function (testable without LLM)
    - Export parseGapDiagnosis as pure function (testable without LLM)
    - Export diagnoseGaps as async orchestrator (calls provider.complete)
    - Follow reflection.ts pattern: prompt builder is pure, orchestrator handles I/O
    - Extract LLM response text using same pattern as reflection.ts (handle content as string or ContentBlock[])
    - Do NOT add retry logic — single attempt, fail-safe to not-actionable
  </implementation>
</feature>

<verification>
npx vitest run src/memory/gap-diagnosis.test.ts — all tests pass
npx tsc --noEmit — no type errors
</verification>

<success_criteria>
- Failing tests written and committed (RED)
- Implementation passes all tests (GREEN)
- Refactor if needed (REFACTOR)
- buildGapDiagnosisPrompt produces well-structured CompletionRequest
- parseGapDiagnosis handles valid JSON, invalid JSON, missing fields, out-of-range indices
- diagnoseGaps orchestrates correctly with mock provider
- Fail-safe: all error paths result in not-actionable gaps (never false positive on error)
</success_criteria>

<output>
After completion, create `.planning/phases/31-gap-scanner/31-02-SUMMARY.md`
</output>
