---
phase: 31-gap-scanner
plan: 04
type: execute
---

<objective>
Wire the 3-stage gap scanner pipeline into BackgroundGardener's sleepTick — after dream cycle and self-reflection. Integrate with real DB queries for goals, behavioral signals, session summaries, and scheduled items. Add integration tests verifying the full pipeline.

Purpose: Connect the pure-function Stage 1-3 modules into the live system so gap detection runs during nightly sleep ticks.
Output: Gap scanner wired into memory.ts sleepTick, exports from memory/index.ts, integration tests.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-gap-scanner/31-RESEARCH.md

# Key source files:
@src/memory/memory.ts
@src/memory/index.ts
@src/memory/db.ts
@src/memory/gap-scanner.ts
@src/memory/gap-diagnosis.ts
@src/memory/gap-actions.ts
@src/memory/gardener-reflection.test.ts

# Prior plans in this phase:
@.planning/phases/31-gap-scanner/31-01-SUMMARY.md
@.planning/phases/31-gap-scanner/31-02-SUMMARY.md
@.planning/phases/31-gap-scanner/31-03-SUMMARY.md

# Related wiring patterns:
@.planning/phases/30-self-reflection/30-02-SUMMARY.md
@.planning/phases/28-dream-rem-exploration/28-03-SUMMARY.md

**Tech stack available:** gap-scanner.ts, gap-diagnosis.ts, gap-actions.ts from 31-01/02/03
**Established patterns:** sleepTick per-user iteration, per-step error isolation try/catch, dynamic import for GoalService, fusionProvider opt-in, workspace-gated features
**Constraining decisions:**
- Phase 30-02: Reflection runs after dream cycle with independent error boundary
- Phase 24-04: Dynamic import for GoalService to avoid circular dependency
- Phase 24-04: Trust score stored as plain key 'proactivenessDial' in behavioral patterns
- Research: Gap scanner runs after reflection in sleepTick, with its own error boundary
- Research: Reuse fusionProvider for Stage 2 LLM calls (same cheap LLM)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire gap scanner pipeline into sleepTick</name>
  <files>src/memory/memory.ts, src/memory/index.ts</files>
  <action>
    In memory.ts sleepTick(), add a new phase after self-reflection (after line 708's closing brace, before "Sleep tick complete" log):

    1. Import gap-scanner modules at top: scanForGaps, GapScanInput, GapSignal from gap-scanner.ts; diagnoseGaps, UserContext from gap-diagnosis.ts; createGapActions from gap-actions.ts

    2. Add gap scanner phase gated on fusionProvider (same gate as reflection — if no provider, skip):
       ```
       // Phase 31: Gap scanner
       if (this.fusionProvider) {
         try {
           // Reuse same user iteration pattern
           for (const { user_id: userId } of users) {
             try {
               // Gather Stage 1 inputs
               const sessionSummaries = db.getSessionSummariesByUser(userId, 20);
               const behavioralPatterns = db.getBehavioralPatterns(userId);
               const existingItems = db.getScheduledItemsByUser(userId);

               // Dynamic import GoalService (same pattern as deepTick step 7)
               const GoalService = (await import('../goals/goal-service.js')).GoalService;
               const goalService = new GoalService({ db, logger: this.logger });
               const activeGoals = await goalService.listGoals(userId, { status: 'active' });

               // Stage 1: Scan for gaps (pure, no LLM)
               const signals = scanForGaps({
                 activeGoals,
                 behavioralSignals: behavioralPatterns,
                 sessionSummaries,
               });

               if (signals.length === 0) continue;

               // Stage 2: LLM diagnosis
               const dial = (behavioralPatterns?.responsePreferences?.proactivenessDial as string) ?? 'moderate';
               const affect = behavioralPatterns?.smoothedAffect ?? null;
               const recentTopics = sessionSummaries.slice(0, 5).flatMap(s => s.topics ?? []);

               const diagnosed = await diagnoseGaps(
                 signals,
                 { affect, dial: dial as 'conservative' | 'moderate' | 'eager', recentTopics },
                 this.fusionProvider,
               );

               // Stage 3: Create gated actions
               const pendingItems = existingItems.filter(i => i.status === 'pending');
               const actions = createGapActions(
                 diagnosed,
                 dial as 'conservative' | 'moderate' | 'eager',
                 pendingItems.map(i => ({ message: i.message })),
               );

               // Insert scheduled items
               for (const action of actions) {
                 db.addScheduledItem({
                   userId,
                   source: 'agent',
                   type: 'follow_up',
                   message: action.scheduledItem.message,
                   context: action.scheduledItem.context,
                   triggerAt: action.scheduledItem.triggerAt,
                   sourceMemoryId: null,
                 });
               }

               if (actions.length > 0) {
                 this.logger.info({ userId, signalsFound: signals.length, actionsCreated: actions.length }, 'Gap scanner created actions');
               }
             } catch (err) {
               this.logger.warn({ error: (err as Error).message, userId }, 'Gap scanner failed for user');
             }
           }
         } catch (err) {
           this.logger.warn({ error: (err as Error).message }, 'Gap scanner phase failed');
         }
       }
       ```

    3. In memory/index.ts, add exports for all gap scanner modules:
       - Export from gap-scanner.ts: scanForGaps, scanStaleGoals, scanBehavioralAnomalies, scanUnresolvedThreads, GapSignal, GapScanInput
       - Export from gap-diagnosis.ts: diagnoseGaps, buildGapDiagnosisPrompt, parseGapDiagnosis, DiagnosedGap, UserContext
       - Export from gap-actions.ts: createGapActions, GapAction, DIAL_THRESHOLDS

    Error isolation: Gap scanner failure must NOT affect dream cycle or reflection results. Outer try/catch wraps the entire gap scanner phase. Inner try/catch per user prevents one user's failure from blocking others.
  </action>
  <verify>npx tsc --noEmit — no type errors. Existing gardener tests still pass: npx vitest run src/memory/gardener</verify>
  <done>Gap scanner phase wired into sleepTick after reflection, all existing tests still pass, exports added to index.ts</done>
</task>

<task type="auto">
  <name>Task 2: Add integration tests for gap scanner in sleepTick</name>
  <files>src/memory/gardener-gap-scanner.test.ts</files>
  <action>
    Create integration test file following gardener-reflection.test.ts pattern:

    1. Setup: Real SQLite via ScallopStore, mock fusionProvider (returns JSON diagnosis response), create test user with sessions, behavioral patterns, and goals

    2. Tests:
       a. "creates scheduled items when stale goals detected" — seed a user with an active goal that hasn't been updated in 20 days. Run sleepTick. Verify db.getScheduledItemsByUser returns new follow_up item with gap context.

       b. "skips gap scanner when no fusionProvider" — create BackgroundGardener without fusionProvider. Run sleepTick. Verify no scheduled items created, no errors.

       c. "skips gap scanner when no signals detected" — seed user with recently-updated goals and healthy behavioral signals. Run sleepTick. Verify no scheduled items created (Stage 1 returns empty).

       d. "error isolation: gap scanner failure does not affect dream/reflection" — mock fusionProvider to throw on gap diagnosis prompt (detect via prompt content containing "DETECTED SIGNALS"). Verify sleepTick completes without error, dream/reflection results still saved.

       e. "respects proactiveness dial gating" — seed user with conservative dial and a low-severity signal. Mock LLM to diagnose as actionable with low confidence. Verify no scheduled items created (conservative filters it out).

    3. Use same test patterns as gardener-reflection.test.ts: real ScallopStore, Date.now mock for time control, afterEach cleanup.

    4. Mock fusionProvider.complete to distinguish between gap diagnosis calls (prompt contains "DETECTED SIGNALS") vs dream/reflection calls — return appropriate mock response for each.
  </action>
  <verify>npx vitest run src/memory/gardener-gap-scanner.test.ts — all 5 tests pass. npx vitest run src/memory/gardener — all gardener tests pass (existing + new).</verify>
  <done>5 integration tests passing: scheduled item creation, no-provider skip, no-signals skip, error isolation, dial gating. All existing gardener tests unaffected.</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] npx tsc --noEmit passes
- [ ] npx vitest run src/memory/gap-scanner.test.ts — all pass
- [ ] npx vitest run src/memory/gap-diagnosis.test.ts — all pass
- [ ] npx vitest run src/memory/gap-actions.test.ts — all pass
- [ ] npx vitest run src/memory/gardener-gap-scanner.test.ts — all pass
- [ ] npx vitest run src/memory/gardener — all gardener tests pass
- [ ] No regressions in existing test suite
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Gap scanner wired into sleepTick after reflection with proper error isolation
- Integration tests verify full pipeline: signal detection → LLM diagnosis → gated action creation → scheduled item insertion
- Phase 31 complete, ready for Phase 32 (Inner Thoughts & Timing)
</success_criteria>

<output>
After completion, create `.planning/phases/31-gap-scanner/31-04-SUMMARY.md`:

# Phase 31 Plan 04: Wire Gap Scanner into sleepTick Summary

**[Substantive one-liner]**

## Accomplishments
## Files Created/Modified
## Decisions Made
## Issues Encountered
## Next Phase Readiness
</output>
