---
phase: 25-affect-detection
plan: 03
type: execute
---

<objective>
Wire affect detection into the SmartBot infrastructure: add affect EMA fields to BehavioralPatterns storage, integrate classifyAffect into per-message processing, update profiles to format affect for LLM context, and export all new types from memory index.

Purpose: Connect the pure-function classifier (Plan 01) and EMA smoother (Plan 02) to the running system so affect is computed per-message and available for Phase 26 context injection.
Output: Affect integrated into DB storage, profile formatting, and module exports. Phase 25 complete.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-affect-detection/25-RESEARCH.md
@.planning/phases/25-affect-detection/25-01-SUMMARY.md
@.planning/phases/25-affect-detection/25-02-SUMMARY.md

# Key source files:
@src/memory/db.ts
@src/memory/profiles.ts
@src/memory/memory.ts
@src/memory/index.ts
@src/memory/affect.ts
@src/memory/affect-smoothing.ts
@src/memory/affect-lexicon.ts

**Tech stack available:** affect.ts (classifyAffect), affect-smoothing.ts (updateAffectEMA, getSmoothedAffect), behavioral-signals.ts (updateEMA)
**Established patterns:**
- Signal storage in response_preferences JSON column (Phase 22 pattern for behavioral signals)
- Plain keys for v4.0 patterns (Phase 24 decision — NOT _sig_ prefix)
- Dynamic import for cross-module tick dependencies (Phase 24 pattern)
- try-catch-per-step deepTick extension (Phase 24 pattern)

**Constraining decisions:**
- Phase 22: Store signals in response_preferences JSON to avoid schema migration
- Phase 24: Use plain keys (not _sig_ prefix) for v4.0 patterns
- RESEARCH.md: Affect EMA state goes in behavioral_patterns table; currentMood in dynamic_profiles updated with emotion label for backward compatibility
- RESEARCH.md: Per-message classification (not batch in tick) — mood changes within sessions matter
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add affect EMA storage to BehavioralPatterns and wire per-message classification</name>
  <files>src/memory/db.ts, src/memory/memory.ts, src/memory/scallop-store.ts</files>
  <action>
    **db.ts changes:**
    1. Import SmoothedAffect and AffectEMAState types from affect-smoothing.ts
    2. Add to BehavioralPatterns interface:
       - `affectState: AffectEMAState | null` — the raw EMA state for continuation
       - `smoothedAffect: SmoothedAffect | null` — the derived mood/emotion/goalSignal
    3. In updateBehavioralPatterns: store affectState and smoothedAffect as plain keys (NOT _sig_ prefix) in the response_preferences JSON column. Follow the existing pattern for messageFrequency etc but use plain key names: `affectState`, `smoothedAffect`.
    4. In getBehavioralPatterns (rowToBehavioralPatterns): deserialize affectState and smoothedAffect from response_preferences JSON. Return null for each if not present (backward compat).

    **memory.ts changes (BackgroundGardener or ScallopMemoryStore message handler):**
    1. Find where user messages are processed (the method that handles incoming messages — likely in scallop-store.ts or memory.ts where addMessage/processMessage occurs).
    2. After a user message is received, call classifyAffect(messageText) to get RawAffect.
    3. Load current AffectEMAState from behavioral patterns (or createInitialAffectState() if null).
    4. Call updateAffectEMA(state, rawAffect, Date.now()) to get new state.
    5. Call getSmoothedAffect(newState) to get SmoothedAffect.
    6. Store updated affectState and smoothedAffect via updateBehavioralPatterns.
    7. Update dynamic profile currentMood with smoothedAffect.emotion (backward compat with existing mood display).
    8. Use dynamic import pattern (like Phase 24) to avoid circular deps if needed.
    9. Only process user messages (role === 'user'), NOT assistant messages — to prevent bot contamination (RESEARCH.md pitfall).

    **IMPORTANT:** Do NOT create a new DB table or column. Store in response_preferences JSON following the Phase 22 established pattern. Use plain keys per Phase 24 decision.
  </action>
  <verify>npx tsc --noEmit (no type errors), npx vitest run src/memory/ --reporter=verbose (all existing tests still pass)</verify>
  <done>BehavioralPatterns interface has affectState and smoothedAffect fields. Per-message affect classification runs on user messages. EMA state persisted via response_preferences JSON. currentMood updated with emotion label. No existing tests broken.</done>
</task>

<task type="auto">
  <name>Task 2: Format affect signals for LLM context and export from memory index</name>
  <files>src/memory/profiles.ts, src/memory/index.ts</files>
  <action>
    **profiles.ts changes:**
    1. In formatProfileContext(), after the existing behavioral patterns section, add affect display:
       - If profile.behavioral?.smoothedAffect exists:
         - Add `- Current affect: {emotion} (valence: {valence.toFixed(2)}, arousal: {arousal.toFixed(2)})`
         - If goalSignal !== 'stable': add `- Mood signal: {goalSignal}` (e.g., "Mood signal: user_distressed")
       - This goes in the behavioralPatterns section of the formatted output, NOT as instructions (per Mozikov et al. — observation block only, Phase 26 will handle instruction injection).
    2. Existing `currentMood` display in dynamic context section remains (backward compat) — it will now show the emotion label from affect classifier instead of LLM-extracted mood strings.

    **index.ts changes:**
    1. Export from affect.ts: classifyAffect, mapToEmotion, type RawAffect, type EmotionLabel
    2. Export from affect-smoothing.ts: updateAffectEMA, deriveGoalSignal, getSmoothedAffect, createInitialAffectState, type AffectEMAState, type GoalSignal, type SmoothedAffect
    3. Export from affect-lexicon.ts: AROUSAL_MAP, NEGATION_WORDS, BOOSTER_DICT, EMOJI_VALENCE, N_SCALAR (for potential external use/testing)
    4. Follow existing export grouping pattern with comment headers.
  </action>
  <verify>npx tsc --noEmit (no type errors), npx vitest run --reporter=verbose (all tests pass including affect tests)</verify>
  <done>Affect signals appear in formatProfileContext output. All affect types and functions exported from memory/index.ts. Full test suite passes. Phase 25 complete.</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npx tsc --noEmit` — no TypeScript errors
- [ ] `npx vitest run` — all tests pass (existing + new affect tests)
- [ ] affect.ts, affect-lexicon.ts, affect-smoothing.ts all exist with exports
- [ ] BehavioralPatterns interface has affectState and smoothedAffect fields
- [ ] Per-message affect classification is wired (user messages only)
- [ ] formatProfileContext includes affect display when available
- [ ] All new types/functions exported from memory/index.ts
- [ ] currentMood in dynamic profile updated with emotion label
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors or test regressions
- Per-message affect classification runs on user messages
- Affect EMA state persisted in behavioral_patterns (response_preferences JSON, plain keys)
- currentMood backward-compatible (updated with emotion label)
- Affect displayed in LLM context (observation block, not instructions)
- All new exports accessible from memory/index.ts
- Phase 25 complete — ready for Phase 26 (affect context injection)
  </success_criteria>

<output>
After completion, create `.planning/phases/25-affect-detection/25-03-SUMMARY.md`:

# Phase 25 Plan 3: Wire Affect Integration Summary

**[one-liner]**

## Accomplishments
- [list]

## Files Created/Modified
- [list]

## Decisions Made
[decisions]

## Issues Encountered
[issues]

## Next Step
Phase 25 complete. Ready for Phase 26: Affect Context Injection.
</output>
