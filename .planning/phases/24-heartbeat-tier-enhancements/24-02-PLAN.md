---
phase: 24-heartbeat-tier-enhancements
plan: 02
type: tdd
---

<objective>
Implement trust score computation as a pure function with full TDD.

Purpose: Create the trust scoring module that computes a 0.0-1.0 trust score from observable user signals, mapping to a proactiveness dial (conservative/moderate/eager). This calibrates how aggressively the agent initiates proactive actions (Phase 31-32).
Output: `src/memory/trust-score.ts` with tests, following v3.0 stateless pure function + cold-start pattern.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/tdd.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/24-heartbeat-tier-enhancements/24-RESEARCH.md

@src/memory/behavioral-signals.ts
@src/memory/db.ts

**Tech stack available:** better-sqlite3, pino (all existing)
**Established patterns:** EMA smoothing (updateEMA from behavioral-signals.ts), cold-start null return, _sig_ prefix storage
**Constraining decisions:**
- Research: Default trust 0.5 (neutral) for insufficient data
- Research: Cold-start threshold: at least 5 sessions AND at least 1 proactive item before computing real trust
- Research: Trust formula: weighted combination of sessionReturnRate, avgSessionDuration, proactiveAcceptRate, proactiveDismissRate, explicitFeedback
- Research: Store as _sig_trust in response_preferences (follows _sig_ prefix pattern)
- Research: Proactiveness dial mapping: 0.0-0.3 → conservative, 0.3-0.7 → moderate, 0.7-1.0 → eager
</context>

<feature>
  <name>Trust Score Computation</name>
  <files>src/memory/trust-score.ts, src/memory/trust-score.test.ts</files>
  <behavior>
    computeTrustScore(sessions, scheduledItems, options?) returns TrustScoreResult | null:

    Inputs:
    - sessions: Array of { messageCount, durationMs, startTime }
    - scheduledItems: Array of { status: 'pending'|'fired'|'acted'|'dismissed', source: string, firedAt?: number }
    - options?: { existingScore?: number } for EMA smoothing with previous value

    Output TrustScoreResult:
    - trustScore: 0.0-1.0
    - proactivenessDial: 'conservative' | 'moderate' | 'eager'
    - signals: TrustSignals object with individual signal values

    Cases:
    - Cold start (< 5 sessions) → returns null
    - Cold start (0 scheduled items) → computes from sessions only, proactive signals default to 0.5
    - Active user, all proactive items acted on → high trust (>0.7), eager dial
    - Active user, all proactive items dismissed → low trust (<0.3), conservative dial
    - Moderate user → trust ~0.5, moderate dial
    - With existingScore → EMA smooths new score toward existing (prevents wild swings)
    - Empty sessions array → returns null
    - Sessions with 0 duration → handles gracefully (no NaN)

    Signal weights (from research):
    - sessionReturnRate: 0.25 (sessions per week, normalized to 0-1 via sigmoid)
    - avgSessionDuration: 0.15 (EMA-smoothed, normalized)
    - proactiveAcceptRate: 0.30 (highest weight — direct signal of trust)
    - proactiveDismissRate: -0.20 (negative weight — active rejection)
    - explicitFeedback: 0.10 (net positive/negative from metadata)

    Dial mapping:
    - trustScore < 0.3 → 'conservative'
    - trustScore 0.3-0.7 → 'moderate'
    - trustScore >= 0.7 → 'eager'
  </behavior>
  <implementation>
    Pure function. Compute each signal independently:
    1. sessionReturnRate: count sessions in last 7 days, normalize with sigmoid(x/7) where 7 sessions/week = ~1.0
    2. avgSessionDuration: EMA over session durations using updateEMA from behavioral-signals.ts
    3. proactiveAcceptRate: count(status='acted') / count(status in ('acted','dismissed','fired')) — only items that had a chance to be acted on
    4. proactiveDismissRate: count(status='dismissed') / same denominator
    5. explicitFeedback: placeholder (0.5 neutral) — no explicit feedback mechanism yet

    Weighted sum → clamp to [0, 1] → map to dial.
    If existingScore provided, EMA-smooth: weight=0.3 for new, 0.7 for existing (trust should change slowly).
    Follow cold-start pattern: return null if insufficient data.
  </implementation>
</feature>

<verification>
- `npx vitest run src/memory/trust-score.test.ts` — all tests pass
- `npx vitest run` — no regressions
</verification>

<success_criteria>
- Failing tests written and committed
- Implementation passes all tests
- Cold start returns null (not 0 or NaN)
- Trust score always in [0, 1] range
- Dial mapping is correct at boundaries
- EMA smoothing prevents wild swings when existingScore provided
- No new dependencies added
- All commits present (2-3)
</success_criteria>

<output>
After completion, create `.planning/phases/24-heartbeat-tier-enhancements/24-02-SUMMARY.md`
</output>
