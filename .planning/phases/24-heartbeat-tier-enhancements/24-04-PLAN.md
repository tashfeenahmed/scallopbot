---
phase: 24-heartbeat-tier-enhancements
plan: 04
type: execute
---

<objective>
Wire health ping, retrieval audit, trust scoring, and goal deadline checks into BackgroundGardener's tick methods.

Purpose: Integrate the pure functions from Plans 01-03 into the gardener's existing lightTick and deepTick orchestration, following the established try-catch-per-step pattern. Also export all new types from memory/index.ts.
Output: Extended BackgroundGardener with 4 new operations wired into the tick pipeline.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/24-heartbeat-tier-enhancements/24-RESEARCH.md
@.planning/phases/24-heartbeat-tier-enhancements/24-01-SUMMARY.md
@.planning/phases/24-heartbeat-tier-enhancements/24-02-SUMMARY.md
@.planning/phases/24-heartbeat-tier-enhancements/24-03-SUMMARY.md

@src/memory/memory.ts
@src/memory/health-ping.ts
@src/memory/retrieval-audit.ts
@src/memory/trust-score.ts
@src/memory/goal-deadline-check.ts
@src/memory/index.ts
@src/goals/goal-service.ts
@src/memory/db.ts

**Tech stack available:** All existing
**Established patterns:** try-catch per deepTick step, fire-and-forget async from lightTick, opt-in provider injection
**Constraining decisions:**
- Research: Health ping in lightTick (sync only)
- Research: Retrieval audit, trust update, goal deadline check in deepTick (async)
- Research: Each operation wrapped in independent try-catch (existing pattern)
- Research: Do NOT block lightTick with async operations
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire health ping into lightTick and deep tick operations into deepTick</name>
  <files>src/memory/memory.ts, src/memory/index.ts</files>
  <action>
  1. Import performHealthPing from health-ping.ts, auditRetrievalHistory from retrieval-audit.ts, computeTrustScore from trust-score.ts, checkGoalDeadlines from goal-deadline-check.ts.

  2. In lightTick(), after expireOldScheduledItems and before tickCount check, add health ping call:
     ```
     try {
       const db = this.scallopStore.getDatabase();
       const health = performHealthPing(db);
       this.logger.debug({ ...health }, 'Health ping');
     } catch (err) {
       this.logger.warn({ error: (err as Error).message }, 'Health ping failed');
     }
     ```
     Health ping is sync — safe for lightTick.

  3. In deepTick(), after behavioral pattern inference (step 4), add three new steps:

     Step 5 — Retrieval audit:
     ```
     try {
       const auditResult = auditRetrievalHistory(db);
       if (auditResult.neverRetrieved > 0 || auditResult.staleRetrieved > 0) {
         this.logger.info({ ...auditResult, candidateCount: auditResult.candidatesForDecay.length }, 'Retrieval audit complete');
       }
     } catch (err) {
       this.logger.warn({ error: (err as Error).message }, 'Retrieval audit failed');
     }
     ```

     Step 6 — Trust score update:
     ```
     try {
       const profileManager = this.scallopStore.getProfileManager();
       const sessionSummaries = db.getSessionSummariesByUser('default', 30);
       const sessions = sessionSummaries
         .filter(s => s.messageCount > 0)
         .map(s => ({ messageCount: s.messageCount, durationMs: s.durationMs, startTime: s.createdAt }));
       const scheduledItems = db.getScheduledItemsByUser ? db.getScheduledItemsByUser('default') : [];
       const existingProfile = profileManager.getProfile('default');
       const existingTrust = existingProfile?.responsePreferences?._sig_trust as number | undefined;
       const trustResult = computeTrustScore(sessions, scheduledItems, { existingScore: existingTrust });
       if (trustResult) {
         profileManager.updateSignal('default', '_sig_trust', trustResult.trustScore);
         profileManager.updateSignal('default', '_sig_proactiveness_dial', trustResult.proactivenessDial);
         this.logger.debug({ trustScore: trustResult.trustScore, dial: trustResult.proactivenessDial }, 'Trust score updated');
       }
     } catch (err) {
       this.logger.warn({ error: (err as Error).message }, 'Trust score update failed');
     }
     ```

     Note: If `getScheduledItemsByUser` doesn't exist on db, add a simple wrapper that queries scheduled_items by user_id. Check db.ts first.

     Step 7 — Goal deadline check:
     ```
     try {
       const GoalService = (await import('../goals/goal-service.js')).GoalService;
       const goalService = new GoalService({ db, logger: this.logger });
       const activeGoals = await goalService.listGoals('default', { status: 'active' });
       const goalsWithDueDates = activeGoals.filter(g => g.metadata.dueDate != null);
       if (goalsWithDueDates.length > 0) {
         const pendingItems = db.getDueScheduledItems(Date.now() + 30 * 24 * 60 * 60 * 1000); // get all pending items within 30 days
         const existingReminders = pendingItems.map(item => ({ message: item.message }));
         const deadlineResult = checkGoalDeadlines(goalsWithDueDates, existingReminders);
         for (const notification of deadlineResult.notifications) {
           if (!db.hasSimilarPendingScheduledItem(notification.userId, notification.message)) {
             db.addScheduledItem({
               userId: notification.userId,
               message: notification.message,
               triggerAt: Date.now(),
               source: 'goal-deadline',
               channel: 'default',
             });
           }
         }
         if (deadlineResult.approaching.length > 0) {
           this.logger.info({ approaching: deadlineResult.approaching.length, notifications: deadlineResult.notifications.length }, 'Goal deadline check complete');
         }
       }
     } catch (err) {
       this.logger.warn({ error: (err as Error).message }, 'Goal deadline check failed');
     }
     ```

  4. In memory/index.ts, add re-exports for all new types:
     - HealthPingResult from health-ping.ts
     - RetrievalAuditResult from retrieval-audit.ts
     - TrustScoreResult, TrustSignals from trust-score.ts
     - GoalDeadlineResult from goal-deadline-check.ts

  Avoid: Do NOT add any new constructor parameters to BackgroundGardenerOptions for Phase 24. All new operations use existing scallopStore/logger. GoalService is dynamically imported to avoid circular dependency.
  </action>
  <verify>
  - `npx tsc --noEmit` — no TypeScript errors
  - `npx vitest run src/memory/` — all memory tests pass
  - `npx vitest run` — full suite passes, no regressions
  </verify>
  <done>
  - Health ping runs in every lightTick (sync, no blocking)
  - Retrieval audit, trust update, goal deadline check run in every deepTick
  - Each new step wrapped in independent try-catch
  - No existing behavior changed
  - All new types exported from memory/index.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Add integration test for wired gardener operations</name>
  <files>src/memory/scallop.test.ts</files>
  <action>
  Add a test group in scallop.test.ts (or a new gardener-integration.test.ts if scallop.test.ts is too large) that verifies:

  1. lightTick calls health ping (verify no throw, log output includes health metrics)
  2. deepTick runs retrieval audit (seed a memory with access_count=0, age > 7 days, prominence 0.6, verify it appears in audit log)
  3. deepTick runs trust score (seed some session summaries, verify trust signal is stored in profile)

  Use the existing test patterns from scallop.test.ts — create a test ScallopMemoryStore with in-memory SQLite, run ticks, verify side effects.

  Skip goal deadline integration test here (GoalService adds complexity). The pure function tests from 24-03 cover deadline logic.

  Avoid: Don't test the pure functions again — those are covered in 24-01/02/03. Only test the wiring (correct functions called with correct data from DB).
  </action>
  <verify>
  - `npx vitest run src/memory/` — all tests pass including new integration tests
  - `npx vitest run` — full suite passes
  </verify>
  <done>
  - Integration tests confirm health ping runs in lightTick
  - Integration tests confirm retrieval audit and trust score run in deepTick
  - No existing tests broken
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` succeeds
- [ ] `npx vitest run` — full test suite passes
- [ ] Health ping visible in lightTick debug logs
- [ ] Deep tick operations run sequentially with independent error handling
- [ ] No circular dependencies introduced
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- No existing behavior changed
- 4 new operations wired into BackgroundGardener
- All new types exported from memory/index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/24-heartbeat-tier-enhancements/24-04-SUMMARY.md`
</output>
