---
phase: 22-behavioral-profiling
plan: 02
type: execute
---

<objective>
Wire behavioral signal extractors into ProfileManager and BackgroundGardener, extend the BehavioralPatterns interface, and update context formatting to surface new signals to the LLM.

Purpose: Connect the pure signal functions from 22-01 to the existing behavioral inference pipeline so signals are computed during deep tick and surfaced in conversation context.
Output: Updated ProfileManager with signal computation, extended BehavioralPatterns storage, enriched LLM context formatting.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-behavioral-profiling/22-RESEARCH.md
@.planning/phases/22-behavioral-profiling/22-01-SUMMARY.md

@src/memory/profiles.ts
@src/memory/memory.ts
@src/memory/db.ts
@src/memory/behavioral-signals.ts
@src/memory/index.ts

**Tech stack available:** Vitest, better-sqlite3, existing embedding infrastructure
**Established patterns:** Incremental inference in inferBehavioralPatterns(), opt-in provider injection, re-export from index.ts barrel
**Constraining decisions:**
- Research: Store new signals in existing response_preferences JSON column (no schema migration needed)
- Research: Surface signals as natural-language personality insights, not raw numbers
- Phase 21: Opt-in provider pattern for any new capabilities
- Existing: inferBehavioralPatterns() called from deepTick with all user messages
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend BehavioralPatterns interface and wire signals into inferBehavioralPatterns</name>
  <files>src/memory/db.ts, src/memory/profiles.ts, src/memory/index.ts</files>
  <action>
    1. In db.ts, extend the BehavioralPatterns interface to include new signal fields:
       - `messageFrequency: MessageFrequencySignal | null`
       - `sessionEngagement: SessionEngagementSignal | null`
       - `topicSwitching: TopicSwitchSignal | null`
       - `responseLengthEvolution: ResponseLengthSignal | null`
       Import the signal types from behavioral-signals.ts.

    2. In db.ts `updateBehavioralPatterns()`: Store new signal fields in the existing `response_preferences` JSON column. When writing, merge new signal fields into the response_preferences JSON. When reading in `rowToBehavioralPatterns()`, extract signal fields from response_preferences JSON back into the typed interface fields. This avoids ALTER TABLE entirely — the response_preferences column already stores arbitrary JSON.

    3. In profiles.ts `inferBehavioralPatterns()`: After existing analysis (communication style, active hours, expertise), call the four signal extractors:
       - `computeMessageFrequency()` with message timestamps
       - `computeSessionEngagement()` — requires session data. Add optional `sessions` parameter to inferBehavioralPatterns signature: `sessions?: Array<{messageCount: number, durationMs: number, startTime: number}>`. If not provided, skip session engagement signal.
       - `computeTopicSwitchRate()` — requires embeddings. Add optional `embeddings` parameter: `messageEmbeddings?: Array<{content: string, embedding?: number[]}>`. If not provided, skip topic switching signal. This keeps the function backward-compatible.
       - `computeResponseLengthEvolution()` with message content and timestamps

       Store computed signals via updateBehavioralPatterns with the new fields.

    4. In memory.ts BackgroundGardener.deepTick(): Update the behavioral inference call to also pass session data. Collect session summaries (already queried during summarization step) and pass as the sessions parameter. For embeddings, query recent memories with embeddings for the user and pass to inferBehavioralPatterns. Keep this lightweight — only pass what's already available, don't generate new embeddings.

    5. In index.ts: Re-export signal types and functions from behavioral-signals.ts.

    AVOID: Schema migration (ALTER TABLE). Use existing response_preferences JSON column.
    AVOID: Generating new embeddings during deep tick. Only use existing embeddings from memories.
    AVOID: Breaking the existing inferBehavioralPatterns signature — new params are optional.
  </action>
  <verify>npm run build passes with no type errors. Existing tests still pass: npm test -- src/memory/scallop.test.ts</verify>
  <done>BehavioralPatterns interface extended with 4 signal fields, inferBehavioralPatterns computes signals from messages/sessions/embeddings, deepTick passes session and embedding data, no schema migration needed, backward compatible</done>
</task>

<task type="auto">
  <name>Task 2: Update context formatting and add integration test</name>
  <files>src/memory/profiles.ts, src/memory/scallop.test.ts</files>
  <action>
    1. In profiles.ts `formatProfileContext()`, update the behavioral patterns section to surface new signals as natural-language insights. Format rules:
       - Only include signals that are non-null (cold start protection already handled by compute functions)
       - Message frequency: "Messaging pace: ~{dailyRate}/day ({trend})" — only if dailyRate computed
       - Session engagement: "Session style: ~{avgMessagesPerSession} messages over ~{avgDurationMs/60000} min ({trend})" — only if computed
       - Topic switching: "{switchRate > 0.5 ? 'Explores many topics' : 'Focuses deeply on topics'} (avg {avgTopicDepth} messages per topic)" — only if computed
       - Response length: "Message length trend: {trend}" — only if non-stable and computed

       Keep formatting concise. Don't dump raw numbers. The LLM should understand the user's communication personality from these one-liners.

    2. Add integration test in scallop.test.ts (or profiles.test.ts if exists):
       - Test that inferBehavioralPatterns with sufficient messages populates all 4 signal fields
       - Test that formatProfileContext includes signal insights when signals are populated
       - Test that signals are null/absent when message count is below threshold (cold start)
       - Test backward compatibility: calling inferBehavioralPatterns without optional params still works

    Use the existing test patterns from scallop.test.ts — createMockProvider, test database setup, etc.
  </action>
  <verify>npm test -- src/memory/scallop.test.ts passes. npm test -- src/memory/profiles passes (if test file exists). npm run build succeeds.</verify>
  <done>Context formatting surfaces behavioral signals as natural-language insights, integration tests verify end-to-end signal computation and formatting, cold start protection works, backward compatible</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm test` passes all tests (existing + new)
- [ ] `npm run lint` passes
- [ ] BehavioralPatterns interface has 4 new signal fields
- [ ] inferBehavioralPatterns computes all 4 signals when data available
- [ ] formatProfileContext shows natural-language signal insights
- [ ] Cold start: signals are null when insufficient data
- [ ] Backward compatible: no breaking changes to existing callers
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors or test regressions
- Behavioral signals flow end-to-end: deepTick → inferBehavioralPatterns → compute functions → storage → formatProfileContext
- Phase 22 complete
</success_criteria>

<output>
After completion, create `.planning/phases/22-behavioral-profiling/22-02-SUMMARY.md`

Include:
- Files modified
- How signals are stored (response_preferences JSON)
- Context formatting examples
- Any deviations from plan
- Phase 22 complete status
</output>
