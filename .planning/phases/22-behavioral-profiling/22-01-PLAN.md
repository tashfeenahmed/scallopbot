---
phase: 22-behavioral-profiling
plan: 01
type: tdd
---

<objective>
TDD pure signal extractor functions for behavioral profiling: message frequency, session engagement, topic switching, and response length evolution.

Purpose: Create testable, pure-function signal extractors that take message arrays + existing state and return updated signal values. These follow the same pure-function pattern as reranker.ts, fusion.ts, and activation.ts.
Output: `src/memory/behavioral-signals.ts` with 4 exported functions + `src/memory/behavioral-signals.test.ts` with comprehensive tests.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/tdd.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-behavioral-profiling/22-RESEARCH.md
@.planning/phases/21-memory-fusion-engine/21-02-SUMMARY.md

@src/memory/profiles.ts
@src/memory/db.ts

**Tech stack available:** Vitest, better-sqlite3, existing embedding infrastructure
**Established patterns:** Pure function + callback pattern (reranker, fusion, activation), incremental analysis with merge semantics, opt-in provider injection
**Constraining decisions:**
- Phase 18: Pure function pattern with LLMProvider injection
- Phase 21: Opt-in provider via constructor options
- Research: Use EMA for temporal smoothing, cosine similarity for topic switching, trend detection via half-split comparison
- Research: Return null until minimum message threshold met (cold start protection)
- Research: No new dependencies — pure math on existing data
</context>

<feature>
  <name>Behavioral signal extractor functions</name>
  <files>src/memory/behavioral-signals.ts, src/memory/behavioral-signals.test.ts</files>
  <behavior>
    Four pure functions, each taking messages + existing signal state → updated signal:

    **1. computeMessageFrequency(messages, existing) → MessageFrequencySignal | null**
    - Input: Array of {timestamp: number}, existing signal or null
    - Returns null if fewer than 10 messages (cold start)
    - Computes messages-per-day using EMA smoothing (halfLife = 7 days)
    - Groups messages into daily buckets, computes EMA over daily counts
    - Determines trend: 'increasing' | 'decreasing' | 'stable' via half-split comparison (>15% delta = trend)
    - Returns: { dailyRate: number, weeklyAvg: number, trend: string, lastComputed: number }

    **2. computeSessionEngagement(sessions, existing) → SessionEngagementSignal | null**
    - Input: Array of {messageCount: number, durationMs: number, startTime: number}, existing signal or null
    - Returns null if fewer than 3 sessions
    - Computes EMA-smoothed average session length (message count) and duration
    - Determines engagement trend from session durations
    - Returns: { avgMessagesPerSession: number, avgDurationMs: number, trend: string, lastComputed: number }

    **3. computeTopicSwitchRate(messages, existing) → TopicSwitchSignal | null**
    - Input: Array of {content: string, embedding?: number[]}, existing signal or null
    - Returns null if fewer than 5 messages with embeddings
    - Compares consecutive message embeddings via cosine similarity
    - Similarity < 0.3 = topic switch
    - Computes: switch rate (switches / total transitions), average topic depth (messages before switch)
    - Returns: { switchRate: number, avgTopicDepth: number, totalSwitches: number, lastComputed: number }

    **4. computeResponseLengthEvolution(messages, existing) → ResponseLengthSignal | null**
    - Input: Array of {content: string, timestamp: number}, existing signal or null
    - Returns null if fewer than 10 messages
    - Computes EMA-smoothed average message length over time
    - Determines trend in message length
    - Returns: { avgLength: number, trend: string, lastComputed: number }

    **Helper: updateEMA(currentValue, previousEMA, timeDeltaMs, halfLifeMs) → number**
    - Pure EMA computation for irregular time series
    - Formula: weight = 1 - exp(-timeDelta / halfLife); return weight * current + (1 - weight) * previous

    **Helper: detectTrend(values: number[]) → 'increasing' | 'decreasing' | 'stable'**
    - Split values in half, compare averages
    - Delta > 15% = increasing, < -15% = decreasing, else stable
    - Returns 'stable' if fewer than 4 values

    **Helper: cosineSimilarity(a: number[], b: number[]) → number**
    - Standard cosine similarity (may reuse from scallop-store if exported, otherwise implement locally)

    Test cases:
    - Cold start: <10 messages → null for frequency/length, <3 sessions → null for engagement, <5 embedded messages → null for topic switch
    - Single day: all messages same day → daily rate reflects that
    - Multi-day spread: messages across 14 days → EMA-smoothed daily rate
    - Increasing trend: more messages in second half → trend 'increasing'
    - Decreasing trend: fewer messages in second half → trend 'decreasing'
    - Stable: roughly equal → trend 'stable'
    - Topic switch: dissimilar embeddings → high switch rate
    - Topic continuity: similar embeddings → low switch rate, high avg depth
    - Session engagement: short sessions → low avg, long sessions → high avg
    - Response length evolution: longer messages over time → 'increasing' trend
    - Edge: empty arrays → null
    - Edge: all same timestamp → handled gracefully
  </behavior>
  <implementation>
    Create src/memory/behavioral-signals.ts with:
    - Export interfaces: MessageFrequencySignal, SessionEngagementSignal, TopicSwitchSignal, ResponseLengthSignal, BehavioralSignals (union container)
    - Export pure functions: computeMessageFrequency, computeSessionEngagement, computeTopicSwitchRate, computeResponseLengthEvolution
    - Export helpers: updateEMA, detectTrend
    - Internal helper: cosineSimilarity (or import from existing code)

    All functions are stateless and testable. No database access, no side effects.

    EMA halfLife defaults: 7 days (7 * 24 * 60 * 60 * 1000 ms) for frequency and length, session-count-based for engagement.

    Follow existing patterns from fusion.ts and activation.ts — pure functions with typed inputs/outputs.
  </implementation>
</feature>

<verification>
npm test -- src/memory/behavioral-signals.test.ts
</verification>

<success_criteria>
- All signal interfaces exported
- All 4 compute functions + 2 helpers exported
- Cold start protection: returns null below minimum thresholds
- EMA smoothing produces reasonable values (not raw averages)
- Trend detection works for increasing/decreasing/stable
- Topic switch detection uses cosine similarity correctly
- All tests pass
- 2-3 commits (test → feat → optional refactor)
</success_criteria>

<output>
After completion, create `.planning/phases/22-behavioral-profiling/22-01-SUMMARY.md`
</output>
