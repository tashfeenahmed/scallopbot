---
phase: 19-llm-guided-relations
plan: 01
type: tdd
---

<objective>
Replace regex-based classifyRelation in RelationGraph with LLM-based classification using the existing RelationshipClassifier, with batch support and graceful regex fallback.

Purpose: The 7-pattern regex heuristic in detectContradiction/detectEnrichment misses semantic relationships (e.g., "Works at Google" → "Joined Google as SWE" isn't detected as UPDATES). LLM classification captures these naturally.
Output: Working, tested LLM-based classifyRelation method with regex fallback.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/tdd.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-llm-guided-relations/19-RESEARCH.md
@.planning/phases/18-retrieval-reranking/18-01-SUMMARY.md
@.planning/phases/18-retrieval-reranking/18-02-SUMMARY.md

# Key files:
@src/memory/relations.ts
@src/memory/relation-classifier.ts
@src/memory/scallop.test.ts

**Tech stack available:** RelationshipClassifier (relation-classifier.ts), LLMProvider interface, CostTracker
**Established patterns:** Optional LLM provider with graceful fallback (reranker.ts), stateless LLM scoring, constructor injection
**Constraining decisions:**
- Phase 18: Opt-in rerankProvider via constructor — existing behavior unchanged without it
- Phase 18: Graceful fallback on any LLM failure
- Phase 18: Stateless pure functions pattern
**Research findings:**
- Use classifyBatch() with all filtered candidates in single call (avoid N+1)
- Don't break fact-extractor's optimized path (it passes detectRelations: false)
- Keep regex as fallback when LLM unavailable or fails
</context>

<feature>
  <name>LLM-based classifyRelation with batch support and regex fallback</name>
  <files>src/memory/relations.ts, src/memory/relations.test.ts</files>
  <behavior>
    RelationGraph accepts an optional LLMProvider in constructor.

    When LLM provider IS available:
    - detectRelations() collects all similarity-passing candidates, then calls RelationshipClassifier.classify() (single candidate) or classifyBatch() (multiple candidates) in one LLM call
    - Maps ClassificationResult back to DetectedRelation format
    - If LLM fails, falls back to existing regex heuristics for that batch

    When LLM provider is NOT available:
    - Uses existing regex-based detectContradiction/detectEnrichment (current behavior, unchanged)

    Cases:
    - No LLM provider → regex classification (backward compatible)
    - LLM provider + single candidate above extendThreshold → classify() → DetectedRelation
    - LLM provider + multiple candidates above extendThreshold → classifyBatch() → DetectedRelation[]
    - LLM returns UPDATES → DetectedRelation with relationType 'UPDATES', confidence from LLM
    - LLM returns EXTENDS → DetectedRelation with relationType 'EXTENDS', confidence from LLM
    - LLM returns NEW → no relation (null/filtered out)
    - LLM call fails → falls back to regex for all candidates
    - Empty candidates → empty results (no LLM call)
  </behavior>
  <implementation>
    1. Add optional `classifierProvider?: LLMProvider` to RelationGraph constructor (and to createRelationGraph factory)
    2. If classifierProvider provided, create a RelationshipClassifier instance in constructor
    3. Refactor detectRelations():
       - Current: loops through filtered candidates, calls classifyRelation() per candidate
       - New: collect all candidates that pass similarity threshold, then:
         - If classifier exists: build FactToClassify from newMemory + ExistingFact[] from candidates, call classify() (1 candidate) or classifyBatch() (2+), map results to DetectedRelation[]
         - If no classifier: loop through candidates using existing regex classifyRelation() (current behavior)
       - On LLM error: catch and fall back to regex loop for all candidates
    4. Keep detectContradiction/detectEnrichment private methods — used as fallback
    5. Keep early exit on high-confidence UPDATE (>=0.85) — apply to LLM results too
    6. Map ScallopMemoryEntry fields to FactToClassify/ExistingFact:
       - content → content
       - userId → subject (or extract subject from metadata if available)
       - category → category
       - id → id (for ExistingFact)
  </implementation>
</feature>

<verification>
npx vitest run src/memory/relations.test.ts
</verification>

<success_criteria>
- Failing tests written for LLM-based classification (RED)
- Implementation passes all tests (GREEN)
- Regex fallback tests pass (backward compatibility)
- No existing scallop.test.ts tests broken
- 2-3 commits present (test, feat, optional refactor)
</success_criteria>

<output>
After completion, create `.planning/phases/19-llm-guided-relations/19-01-SUMMARY.md`
</output>
