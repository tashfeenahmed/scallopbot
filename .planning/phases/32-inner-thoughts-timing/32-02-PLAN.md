---
phase: 32-inner-thoughts-timing
plan: 02
type: tdd
---

<objective>
Build the timing model — a pure function that determines the optimal delivery time for proactive messages.

Purpose: Replace the fixed 30-minute delay used by the gap scanner with an intelligent timing model that respects quiet hours, prefers user active hours, and handles urgency. This addresses the Microsoft CHI 2025 finding that session-boundary delivery gets 52% engagement vs 38% for mid-task interruptions.
Output: Working, tested `timing-model.ts` with `computeDeliveryTime` and `isInQuietHours` functions.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-inner-thoughts-timing/32-RESEARCH.md
@.planning/phases/32-inner-thoughts-timing/32-01-SUMMARY.md

# Source files (patterns to follow):
@src/memory/trust-score.ts
@src/memory/memory.ts
@src/memory/behavioral-signals.ts

**Established patterns:**
- Pure functions with injectable `now` for deterministic testing (trust-score.ts)
- Quiet hours wrap-around detection (BackgroundGardener.isQuietHours)
- activeHours from behavioral signals

**Constraining decisions:**
- RESEARCH.md: Default active hours 9 AM–10 PM when behavioral data unavailable
- RESEARCH.md: Maximum deferral 24 hours — if can't deliver within 24h, deliver at next non-quiet-hour
- RESEARCH.md: High urgency + not quiet hours → deliver in 5 min
- Phase 24: Quiet hours default 2-5 AM, configurable
</context>

<feature>
  <name>Timing Model</name>
  <files>src/proactive/timing-model.ts, src/proactive/timing-model.test.ts</files>
  <behavior>
    **Types:**
    - `TimingContext`: userActiveHours (number[]), quietHours ({ start: number; end: number }), lastProactiveAt (number | null), currentHour (number), urgency ('low' | 'medium' | 'high'), now (number)
    - `DeliveryTiming`: deliverAt (number), reason (string), strategy ('urgent_now' | 'active_hours' | 'next_active' | 'next_morning')

    **isInQuietHours(hour: number, quiet: { start: number; end: number }): boolean**
    - Returns true if hour is within quiet hours window
    - Handles wrap-around (e.g., start: 23, end: 5 → 23,0,1,2,3,4 are quiet)
    - start === end means no quiet hours (returns false)

    **computeDeliveryTime(context: TimingContext): DeliveryTiming**
    Strategy priority (evaluated in order):
    1. **urgent_now**: urgency === 'high' AND NOT in quiet hours → deliverAt = now + 5 min
    2. **next_morning**: currently in quiet hours → deliverAt = first hour after quiet hours end (on same or next day), at :00 minutes. If urgent, still respect quiet hours.
    3. **active_hours**: currentHour is in userActiveHours → deliverAt = now + 15 min
    4. **next_active**: currentHour is NOT in userActiveHours → deliverAt = next hour in userActiveHours (wrapping around midnight), at :00 minutes
    5. **Fallback**: If no active hours and not in quiet hours → deliverAt = now + 30 min (legacy behavior)

    **Minimum gap enforcement:**
    - If lastProactiveAt is set and deliverAt - lastProactiveAt < 2 hours, push deliverAt to lastProactiveAt + 2 hours
    - Exception: urgency === 'high' bypasses minimum gap

    **Maximum deferral:**
    - If deliverAt > now + 24 hours, cap at now + 24 hours (never defer more than 24h)

    **Default active hours:**
    - If userActiveHours is empty: use [9,10,11,12,13,14,15,16,17,18,19,20,21] (9 AM–9 PM)

    **Test cases:**
    - isInQuietHours: returns true for hour within simple range (2-5 → hour 3)
    - isInQuietHours: returns false for hour outside simple range (2-5 → hour 10)
    - isInQuietHours: handles wrap-around (23-5 → hour 1 is quiet, hour 10 is not)
    - isInQuietHours: start === end means no quiet hours (returns false)
    - computeDeliveryTime: high urgency + not quiet → urgent_now (now + 5 min)
    - computeDeliveryTime: high urgency + quiet hours → next_morning (not urgent_now)
    - computeDeliveryTime: in quiet hours → next_morning with deliverAt after quiet end
    - computeDeliveryTime: in active hours → active_hours (now + 15 min)
    - computeDeliveryTime: outside active hours → next_active at next active hour :00
    - computeDeliveryTime: empty activeHours → uses defaults (9-21)
    - computeDeliveryTime: minimum gap enforced (pushes to lastProactive + 2h)
    - computeDeliveryTime: high urgency bypasses minimum gap
    - computeDeliveryTime: maximum deferral caps at now + 24h
    - computeDeliveryTime: next_active wraps around midnight correctly
  </behavior>
  <implementation>
    Follow trust-score.ts pattern:
    - Constants at top (DEFAULT_ACTIVE_HOURS, MIN_GAP_MS = 2h, MAX_DEFERRAL_MS = 24h, URGENT_DELAY_MS = 5 min, ACTIVE_DELAY_MS = 15 min)
    - Exported interfaces
    - isInQuietHours as exported pure function
    - computeDeliveryTime as exported pure function
    - All time computations use milliseconds internally, hour comparisons for active/quiet
    - Do NOT import from memory.ts (BackgroundGardener) — reimplements isInQuietHours as standalone pure function for testability
    - Place in src/proactive/ alongside scheduler.ts (this is proactive delivery infrastructure)
  </implementation>
</feature>

<verification>
npx vitest run src/proactive/timing-model.test.ts --reporter=verbose
All 14 tests pass.
</verification>

<success_criteria>
- Failing tests written and committed (RED)
- Implementation passes all tests (GREEN)
- Refactor complete if needed
- All 2-3 commits present
- isInQuietHours handles wrap-around correctly
- computeDeliveryTime follows strategy priority
- Minimum gap and maximum deferral enforced
- Pure function — no I/O, no side effects, injectable now
</success_criteria>

<output>
After completion, create `.planning/phases/32-inner-thoughts-timing/32-02-SUMMARY.md`
</output>
