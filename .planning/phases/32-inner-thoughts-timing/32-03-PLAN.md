---
phase: 32-inner-thoughts-timing
plan: 03
type: tdd
---

<objective>
Build the proactive feedback loop and per-channel formatting â€” DB 'acted' status, engagement detection, and channel-specific proactive message formatting.

Purpose: Close the trust calibration feedback loop by tracking whether users engage with or dismiss proactive messages. Per-channel formatting ensures Telegram gets short conversational messages while WebSocket gets structured JSON. Without feedback, the trust score flatlines and the proactiveness dial never adapts.
Output: Working, tested `markScheduledItemActed` DB method, `detectProactiveEngagement` function, and `proactive-format.ts` with channel-specific formatters.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-inner-thoughts-timing/32-RESEARCH.md
@.planning/phases/32-inner-thoughts-timing/32-01-SUMMARY.md
@.planning/phases/32-inner-thoughts-timing/32-02-SUMMARY.md

# Source files:
@src/memory/db.ts
@src/memory/trust-score.ts
@src/channels/api.ts
@src/channels/telegram.ts
@src/triggers/types.ts

**Established patterns:**
- DB methods: markScheduledItemFired, markScheduledItemDismissed (follow same pattern for Acted)
- parseUserIdPrefix for channel detection
- formatMarkdownToHtml for Telegram formatting
- WsResponse type for WebSocket structured messages

**Constraining decisions:**
- RESEARCH.md: 15-min engagement window (conservative â€” err on side of leaving as 'fired')
- RESEARCH.md: Text-based Telegram format (not inline buttons â€” too complex for now)
- RESEARCH.md: 'proactive' type for WsResponse structured data
- DB status currently: pending|fired|dismissed|expired â€” needs 'acted' and 'processing' (processing already exists in claim logic)
- trust-score.ts already consumes 'acted' status in proactiveAcceptRate computation
</context>

<feature>
  <name>Feedback Loop & Per-Channel Formatting</name>
  <files>src/memory/db.ts, src/proactive/proactive-format.ts, src/proactive/proactive-format.test.ts, src/proactive/feedback.ts, src/proactive/feedback.test.ts</files>
  <behavior>
    **Part A: DB markScheduledItemActed (in db.ts)**

    `markScheduledItemActed(id: string): boolean`
    - Updates scheduled_items SET status = 'acted', updated_at = now WHERE id = ?
    - Returns true if row was updated
    - Follow exact pattern of markScheduledItemDismissed

    **Part B: Engagement Detection (feedback.ts)**

    `detectProactiveEngagement(userId: string, recentFiredItems: ScheduledItem[], engagementWindowMs?: number): string[]`
    - Pure function â€” receives items, returns IDs to mark as acted
    - Default engagementWindowMs: 15 * 60 * 1000 (15 minutes)
    - Filters items where: source === 'agent' AND status === 'fired' AND firedAt exists AND (now - firedAt) < engagementWindowMs
    - Returns array of item IDs that should be marked as 'acted'
    - Injectable `now` parameter for testing

    **Test cases for feedback.ts:**
    - Returns empty array when no fired items
    - Returns empty array when all items outside engagement window
    - Returns IDs of items within engagement window
    - Ignores items with source !== 'agent'
    - Ignores items with status !== 'fired'
    - Ignores items without firedAt
    - Respects custom engagementWindowMs
    - Uses injectable now parameter

    **Part C: Per-Channel Proactive Formatting (proactive-format.ts)**

    Types:
    - `ProactiveFormatInput`: message (string), gapType (string | undefined), urgency ('low' | 'medium' | 'high'), source ('inner_thoughts' | 'gap_scanner')

    `formatProactiveForTelegram(input: ProactiveFormatInput): string`
    - Prepends type-based icon: stale_goal â†’ "ðŸŽ¯", approaching_deadline â†’ "â°", unresolved_thread â†’ "ðŸ’¬", behavioral_anomaly â†’ "ðŸ“Š", default â†’ "ðŸ’¡"
    - Truncates message to 250 chars (append "..." if truncated)
    - Appends footer: "\n\n_Reply to discuss, or ignore to dismiss._"
    - Total output should be < 350 chars (well under Telegram's 4096 limit)

    `formatProactiveForWebSocket(input: ProactiveFormatInput): object`
    - Returns { type: 'proactive', content: input.message, category: input.gapType || 'general', urgency: input.urgency, source: input.source }

    `formatProactiveMessage(channel: 'telegram' | 'api', input: ProactiveFormatInput): string | object`
    - Routes to formatProactiveForTelegram or formatProactiveForWebSocket

    **Test cases for proactive-format.ts:**
    - formatProactiveForTelegram: prepends correct icon for each gap type
    - formatProactiveForTelegram: uses default icon for unknown type
    - formatProactiveForTelegram: truncates long messages at 250 chars
    - formatProactiveForTelegram: does not truncate short messages
    - formatProactiveForTelegram: appends dismiss footer
    - formatProactiveForWebSocket: returns structured object with all fields
    - formatProactiveForWebSocket: defaults category to 'general' when gapType undefined
    - formatProactiveMessage: routes to telegram formatter for 'telegram' channel
    - formatProactiveMessage: routes to websocket formatter for 'api' channel
  </behavior>
  <implementation>
    **Part A (db.ts):**
    - Add markScheduledItemActed method right after markScheduledItemDismissed
    - Exact same pattern: UPDATE scheduled_items SET status = 'acted', updated_at = ? WHERE id = ?
    - Also add to ScallopDatabase interface type if it's explicitly typed

    **Part B (feedback.ts):**
    - Place in src/proactive/ alongside scheduler.ts and timing-model.ts
    - Import ScheduledItem type from db.ts
    - Pure function â€” no DB calls, no I/O
    - The caller (in 32-04 wiring) will pass in items from db.getScheduledItemsByUser and call db.markScheduledItemActed for returned IDs

    **Part C (proactive-format.ts):**
    - Place in src/proactive/ alongside scheduler.ts
    - GAP_TYPE_ICONS as const record at top
    - Three exported pure functions
    - Do NOT import from channels/ (keep decoupled â€” channels shouldn't depend on proactive)
    - Do NOT extend WsResponse type here â€” that wiring happens in 32-04

    **Export from proactive/index.ts** (create if doesn't exist, or add exports):
    - Export all from timing-model.ts, feedback.ts, proactive-format.ts
  </implementation>
</feature>

<verification>
npx vitest run src/proactive/proactive-format.test.ts src/proactive/feedback.test.ts --reporter=verbose
All 17 tests pass.
</verification>

<success_criteria>
- Failing tests written and committed (RED)
- Implementation passes all tests (GREEN)
- Refactor complete if needed
- All 2-3 commits present
- markScheduledItemActed follows existing DB method pattern exactly
- detectProactiveEngagement is pure (no DB calls)
- formatProactiveForTelegram output is < 350 chars
- formatProactiveForWebSocket returns structured object
- All functions exported from proactive module
</success_criteria>

<output>
After completion, create `.planning/phases/32-inner-thoughts-timing/32-03-SUMMARY.md`
</output>
