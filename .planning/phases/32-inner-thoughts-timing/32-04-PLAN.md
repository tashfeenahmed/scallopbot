---
phase: 32-inner-thoughts-timing
plan: 04
type: execute
---

<objective>
Wire inner thoughts, timing model, per-channel formatting, and feedback loop into the live pipeline.

Purpose: Connect all Phase 32 pure functions into the running system — inner thoughts runs in deepTick after session summarization, timing model replaces the fixed 30-min delay, per-channel formatting routes through UnifiedScheduler, and engagement detection closes the trust feedback loop. This is the integration plan that makes Phase 32 features live.
Output: Inner thoughts running in deepTick, timing-aware delivery in scheduler, per-channel proactive formatting, and engagement-based trust feedback.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-inner-thoughts-timing/32-RESEARCH.md
@.planning/phases/32-inner-thoughts-timing/32-01-SUMMARY.md
@.planning/phases/32-inner-thoughts-timing/32-02-SUMMARY.md
@.planning/phases/32-inner-thoughts-timing/32-03-SUMMARY.md

# Source files to modify:
@src/memory/memory.ts
@src/memory/index.ts
@src/proactive/scheduler.ts
@src/channels/api.ts
@src/triggers/types.ts

# Pattern reference (prior wiring plans):
@.planning/phases/31-gap-scanner/31-04-SUMMARY.md
@.planning/phases/30-self-reflection/30-02-SUMMARY.md

**Established patterns:**
- Per-user iteration with nested try/catch error isolation (sleepTick gap scanner wiring)
- Dynamic import for cross-module deps (GoalService pattern in deepTick)
- fusionProvider reuse for all LLM calls in background ticks
- getScheduledItemsByUser for reading items, addScheduledItem for insertion
- parseUserIdPrefix for channel detection in trigger routing

**Constraining decisions:**
- RESEARCH.md: Inner thoughts runs in deepTick (6h cycle), NOT sleepTick — timeliness matters
- RESEARCH.md: Timing model replaces fixed 30-min delay in gap scanner AND inner thoughts output
- RESEARCH.md: Engagement detection runs when user sends a message (agent.processMessage boundary)
- Phase 31-04: Gap scanner inserts items with fixed triggerAt = Date.now() + 30 * 60 * 1000 — replace with computeDeliveryTime
- Phase 24-05: deepTick runs every DEEP_EVERY ticks (~6 hours)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire inner thoughts into deepTick and update gap scanner timing</name>
  <files>src/memory/memory.ts, src/memory/index.ts</files>
  <action>
    **In memory.ts deepTick method:**

    After the existing session summarization step (step that creates session summaries), add inner thoughts evaluation:

    1. For each user that had new session summaries in this deep tick cycle:
       - Get the most recent session summary (the one just created)
       - Get recent gap signals by running scanForGaps (reuse the same inputs already gathered in sleepTick, or gather fresh: activeGoals, behavioralPatterns, sessionSummaries)
       - Get affect from behavioralPatterns.smoothedAffect
       - Get dial from behavioralPatterns.responsePreferences.proactivenessDial
       - Get activeHours from behavioralPatterns.activeHours
       - Get lastProactiveAt: query scheduled_items for most recent agent-source fired item
       - Call evaluateInnerThoughts(input, fusionProvider)
       - If result.decision === 'proact': call computeDeliveryTime to get timing, then db.addScheduledItem with the timed triggerAt

    2. Wrap in try/catch per user (same error isolation pattern as gap scanner in sleepTick)

    3. Import evaluateInnerThoughts from './inner-thoughts.js' and computeDeliveryTime from '../proactive/timing-model.js'

    **In memory.ts sleepTick gap scanner section:**

    Replace the fixed `triggerAt: action.scheduledItem.triggerAt` (which is Date.now() + 30 * 60 * 1000) with computeDeliveryTime:
    - For each gap action, compute timing based on: activeHours from behavioral patterns, quietHours from this.quietHours, urgency mapped from gap severity (high → 'high', medium → 'medium', low → 'low'), lastProactiveAt, currentHour
    - Use the computed deliverAt as triggerAt

    **In index.ts:**
    Export evaluateInnerThoughts, shouldRunInnerThoughts, InnerThoughtsInput, InnerThoughtsResult from inner-thoughts.ts

    **What to avoid and WHY:**
    - Do NOT run inner thoughts in sleepTick — it would wait 24h and lose timeliness for session follow-ups
    - Do NOT call scanForGaps inside deepTick — inner thoughts uses gap signals as INPUT but does its own LLM evaluation. If no recent session summary exists for a user in this deep tick, skip inner thoughts for that user.
    - Do NOT remove the gap scanner from sleepTick — inner thoughts augments, doesn't replace
    - Do NOT import GoalService at module level (use dynamic import pattern from deepTick step 7)
  </action>
  <verify>npx tsc --noEmit (type checks pass) and npx vitest run src/memory/gardener-integration.test.ts (existing integration tests still pass)</verify>
  <done>Inner thoughts runs in deepTick for users with new session summaries. Gap scanner in sleepTick uses computeDeliveryTime instead of fixed 30-min delay. No type errors. Existing integration tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Wire timing, formatting, and feedback into UnifiedScheduler</name>
  <files>src/proactive/scheduler.ts, src/channels/api.ts</files>
  <action>
    **In scheduler.ts — Per-channel formatting for agent messages:**

    In the `sendFormattedMessage` method (currently just calls onSendMessage):
    1. Import parseUserIdPrefix from '../triggers/types.js'
    2. Import formatProactiveMessage from './proactive-format.js'
    3. For agent-sourced items: detect channel via parseUserIdPrefix(item.userId)
    4. If channel is 'telegram' or 'api': format message with formatProactiveMessage passing channel, message, and context (parse gapType from item.context JSON if present)
    5. For telegram: send the formatted string via onSendMessage
    6. For api (WebSocket): send formatted string via onSendMessage (the structured JSON will be handled when we extend WsResponse)
    7. For user-sourced items: no change (send as-is)

    **In api.ts — Add 'proactive' to WsResponse type:**

    Add 'proactive' to the WsResponse type union for the `type` field (alongside existing 'trigger', 'response', etc.). Also add optional fields: `category?: string`, `urgency?: string`, `source?: string`.

    Update the TriggerSource.sendMessage in ApiChannel: when message starts with a JSON object containing type 'proactive' (from formatProactiveForWebSocket), parse and send as structured WsResponse. Otherwise send as existing 'trigger' type. Simple approach: check if message is valid JSON with type === 'proactive', if so parse and send structured; else send as trigger.

    **In scheduler.ts — Engagement detection on evaluate():**

    At the start of the evaluate() method (before processing due items):
    1. Import detectProactiveEngagement from './feedback.js'
    2. For each unique userId with recently-fired agent items (within 15 min), if any user has sent a message since the item fired, call detectProactiveEngagement
    3. For each returned ID, call this.db.markScheduledItemActed(id)

    Actually, simpler approach: engagement detection should happen when the USER sends a message, not in scheduler tick. The scheduler doesn't know when users message. Instead:
    - Add a public method `checkEngagement(userId: string): void` to UnifiedScheduler
    - This method: gets scheduled items by user, filters for recently-fired agent items, calls detectProactiveEngagement, marks acted
    - The caller (gateway or agent.processMessage) will call this when a user message arrives

    **What to avoid and WHY:**
    - Do NOT restructure sendFormattedMessage into a complex class hierarchy — keep it simple with if/else on channel type
    - Do NOT make formatProactiveMessage async — it's a pure function
    - Do NOT call checkEngagement from inside evaluate() — scheduler doesn't know when users message
    - Do NOT break existing user-sourced reminder formatting
  </action>
  <verify>npx tsc --noEmit (type checks pass). Manual verification: inspect that agent-sourced scheduled items would get formatted differently per channel.</verify>
  <done>UnifiedScheduler formats agent proactive messages per-channel. WsResponse type includes 'proactive'. checkEngagement method available for callers. No type errors.</done>
</task>

<task type="auto">
  <name>Task 3: Integration test and export wiring</name>
  <files>src/memory/inner-thoughts-integration.test.ts, src/proactive/index.ts</files>
  <action>
    **Create src/proactive/index.ts** (barrel export if doesn't exist):
    - Export everything from './timing-model.js'
    - Export everything from './feedback.js'
    - Export everything from './proactive-format.js'

    **Create integration test (src/memory/inner-thoughts-integration.test.ts):**

    Test the inner thoughts pipeline in a deepTick-like context:
    1. **Test: inner thoughts skips when no recent session summaries** — Mock a user with no session summaries created in last 6h. Verify evaluateInnerThoughts is not called (or returns skip).
    2. **Test: inner thoughts evaluates and creates scheduled item on 'proact'** — Mock a user with recent session summary, mock LLM provider to return proact decision, verify a scheduled_item is inserted with timing from computeDeliveryTime (not fixed 30-min).
    3. **Test: inner thoughts skips on distressed user** — Mock user with distressed goalSignal, verify skip.
    4. **Test: gap scanner uses computeDeliveryTime** — Verify the sleepTick gap scanner creates items with timing from computeDeliveryTime rather than fixed offset.
    5. **Test: engagement detection marks items as acted** — Create a fired agent item within 15 min, call checkEngagement, verify status changed to 'acted'.

    Follow the existing gardener-integration.test.ts and gardener-tier3.test.ts patterns:
    - Use the real ScallopDatabase (in-memory SQLite via :memory:)
    - Mock LLM provider with canned responses
    - Use the real ScallopMemoryStore
    - Test through BackgroundGardener methods

    **What to avoid and WHY:**
    - Do NOT test through the full Gateway — use direct-wired components (established v3.0 E2E pattern)
    - Do NOT duplicate unit test coverage — integration tests focus on wiring correctness, not edge cases
    - Keep to 5 tests max — this is a wiring verification, not comprehensive testing
  </action>
  <verify>npx vitest run src/memory/inner-thoughts-integration.test.ts --reporter=verbose (all 5 tests pass) and npx vitest run (full suite passes, no regressions)</verify>
  <done>Integration tests verify inner thoughts runs in deepTick, gap scanner uses timing model, engagement detection works. Full test suite passes. Proactive module exports wired. Phase 32 complete.</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npx tsc --noEmit` passes (no type errors)
- [ ] `npx vitest run` passes (all existing + new tests)
- [ ] Inner thoughts module: 18+ unit tests passing
- [ ] Timing model: 14+ unit tests passing
- [ ] Feedback + formatting: 17+ unit tests passing
- [ ] Integration: 5 tests passing
- [ ] Gap scanner in sleepTick uses computeDeliveryTime (not fixed 30-min delay)
- [ ] Inner thoughts runs in deepTick after session summarization
- [ ] Per-channel formatting: Telegram gets icon + short + footer, WebSocket gets structured JSON
- [ ] Engagement detection: markScheduledItemActed wired and callable
- [ ] All Phase 32 types/functions exported from memory/index.ts and proactive/index.ts
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Inner thoughts pipeline: session summary → pre-filter → LLM eval → timing → scheduled_item
- Timing model: replaces fixed delay everywhere (gap scanner + inner thoughts)
- Per-channel formatting: Telegram short+footer, WebSocket structured JSON
- Feedback loop: user message → checkEngagement → markActed → trust score adapts
- Phase 32 complete
</success_criteria>

<output>
After completion, create `.planning/phases/32-inner-thoughts-timing/32-04-SUMMARY.md`:

# Phase 32 Plan 04: Wire Inner Thoughts & Timing into Pipeline Summary

**[Substantive one-liner]**

## Accomplishments

- Inner thoughts wired into deepTick
- Gap scanner timing replaced with computeDeliveryTime
- Per-channel proactive formatting in UnifiedScheduler
- Engagement detection closes trust feedback loop
- Integration tests verify wiring

## Files Created/Modified

- `src/memory/memory.ts` - Inner thoughts in deepTick, timing in sleepTick gap scanner
- `src/memory/index.ts` - Exports for inner thoughts types/functions
- `src/proactive/scheduler.ts` - Per-channel formatting, checkEngagement method
- `src/proactive/index.ts` - Barrel exports for proactive module
- `src/channels/api.ts` - 'proactive' WsResponse type
- `src/memory/inner-thoughts-integration.test.ts` - 5 integration tests

## Decisions Made

[Decisions during execution]

## Issues Encountered

[Issues during execution]

## Next Step

Phase 32 complete, ready for Phase 33: E2E Cognitive Testing
</output>
