---
phase: 30-self-reflection
plan: 02
type: execute
---

<objective>
Wire the reflect() module into BackgroundGardener's sleepTick and add integration tests. Self-reflection runs after the dream cycle, reads/writes SOUL.md, and stores insights as `insight`-category memories with DERIVES relations to source session summaries.

Purpose: Complete the self-reflection pipeline by connecting the pure reflect() function to the memory system's nightly processing loop, making the agent's behavioral guidelines evolve from its own interactions.
Output: sleepTick runs self-reflection after dreams, SOUL.md is created/updated, insights stored in memory. Integration tests verify the full pipeline.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-self-reflection/30-RESEARCH.md
@.planning/phases/30-self-reflection/30-01-SUMMARY.md

# Key source files:
@src/memory/memory.ts
@src/memory/reflection.ts
@src/memory/index.ts
@src/memory/db.ts

# Integration test patterns to follow:
@src/memory/gardener-nrem.test.ts
@src/memory/gardener-rem.test.ts
@src/memory/enhanced-forgetting.test.ts

**Tech stack available:** Vitest, BackgroundGardener, ScallopMemoryStore, SessionSummaryRow, reflect(), fs/promises
**Established patterns:**
- sleepTick dream cycle wiring (memory.ts:474-619): per-user loop, error isolation, provider gating
- NREM insight storage: scallopStore.add() → updateMemory('derived') → addRelation('DERIVES') → mark sources
- Integration tests: real SQLite (createDatabase), mock LLM providers, seedMemory helpers
**Constraining decisions:**
- Phase 28: fusionProvider reused for both NREM and REM — self-reflection should also reuse fusionProvider
- Phase 29: per-step error isolation pattern — reflection failure must not affect dream cycle results
- RESEARCH.md: SOUL.md read/write happens in wiring (not in pure reflect()), workspace path needed on gardener
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire reflect() into sleepTick with SOUL.md I/O</name>
  <files>src/memory/memory.ts, src/memory/index.ts</files>
  <action>
    **memory.ts changes:**

    1. Add import for `reflect` from `./reflection.js` and `fs/promises` (as `fsPromises` to avoid conflict)
    2. Add `workspace?: string` to `BackgroundGardenerOptions` interface — optional, reflection skipped if not provided
    3. Store `this.workspace` in constructor
    4. In `sleepTick()`, after the dream cycle try/catch block (after line 614, replacing the "Phase 30: Self-reflection (placeholder)" comment), add self-reflection block:

    ```
    // Phase 30: Self-reflection
    if (this.fusionProvider && this.workspace) {
      try {
        const db = this.scallopStore.getDatabase();
        // Get today's session summaries (all users — iterate per user like dream cycle)
        const userRows = db.raw<{ user_id: string }>('SELECT DISTINCT user_id FROM session_summaries', []);

        for (const { user_id: userId } of userRows) {
          try {
            // Get recent session summaries (last 24h worth)
            const allSummaries = db.getSessionSummariesByUser(userId, 50);
            const oneDayAgo = Date.now() - 24 * 60 * 60 * 1000;
            const todaySummaries = allSummaries.filter(s => s.createdAt >= oneDayAgo);

            if (todaySummaries.length === 0) continue;

            // Read current SOUL.md (may not exist yet)
            let currentSoul: string | null = null;
            const soulPath = path.join(this.workspace, 'SOUL.md');
            try {
              currentSoul = await fsPromises.readFile(soulPath, 'utf-8');
            } catch {
              // First run — SOUL.md doesn't exist yet
            }

            // Generate reflections
            const result = await reflect(todaySummaries, currentSoul, this.fusionProvider);

            if (result.skipped) {
              this.logger.debug({ userId, reason: result.skipReason }, 'Self-reflection skipped');
              continue;
            }

            // Store insights as insight-category memories with DERIVES relations
            for (const insight of result.insights) {
              try {
                const mem = await this.scallopStore.add({
                  userId,
                  content: insight.content,
                  category: 'insight',
                  importance: 7,
                  confidence: 0.85,
                  sourceChunk: insight.sourceSessionIds.join(' | '),
                  metadata: {
                    reflectedAt: new Date().toISOString(),
                    topics: insight.topics,
                    sourceSessionIds: insight.sourceSessionIds,
                  },
                  learnedFrom: 'self_reflection',
                  detectRelations: false,
                });
                db.updateMemory(mem.id, { memoryType: 'derived' });

                // DERIVES relations to source session summary memory entries
                // (session summaries are stored in a separate table, not memories —
                //  so we skip DERIVES relations to sessions and rely on metadata.sourceSessionIds)
              } catch (err) {
                this.logger.warn({ error: (err as Error).message, userId }, 'Reflection insight storage failed');
              }
            }

            // Write updated SOUL.md
            if (result.updatedSoul) {
              try {
                await fsPromises.writeFile(soulPath, result.updatedSoul, 'utf-8');
                this.logger.info({ userId }, 'SOUL.md updated from self-reflection');
              } catch (err) {
                this.logger.warn({ error: (err as Error).message }, 'SOUL.md write failed');
              }
            }

            this.logger.info({
              userId,
              insightsGenerated: result.insights.length,
              soulUpdated: result.updatedSoul !== null,
              sessionsReflected: todaySummaries.length,
            }, 'Self-reflection complete for user');
          } catch (err) {
            this.logger.warn({ error: (err as Error).message, userId }, 'Self-reflection failed for user');
          }
        }
      } catch (err) {
        this.logger.warn({ error: (err as Error).message }, 'Self-reflection phase failed');
      }
    }
    ```

    5. Add `import * as path from 'node:path'` and `import * as fsPromises from 'node:fs/promises'` at top (check if path is already imported)
    6. Update the sleepTick JSDoc to mention Phase 30

    **Important:** Do NOT modify any existing dream cycle code. The self-reflection block is additive only, placed after the dream cycle's closing brace.

    **Note on DERIVES relations:** Session summaries live in `session_summaries` table, not `memories` table. The db.addRelation() function works on memory IDs only. So instead of DERIVES relations, store `sourceSessionIds` in metadata for traceability. This is sufficient — insights are standalone and don't need graph traversal back to session summaries.

    **index.ts changes:**
    Add reflection exports:
    ```
    // Self-Reflection
    export {
      reflect,
      buildReflectionPrompt,
      buildSoulDistillationPrompt,
      DEFAULT_REFLECTION_CONFIG,
      type ReflectionConfig,
      type ReflectionResult,
      type ReflectionInsight,
    } from './reflection.js';
    ```
  </action>
  <verify>npx tsc --noEmit passes (no type errors). Existing tests still pass: npm test -- src/memory/gardener</verify>
  <done>sleepTick calls reflect() after dream cycle, stores insights, writes SOUL.md. Type check passes. Existing gardener tests unaffected.</done>
</task>

<task type="auto">
  <name>Task 2: Integration tests for self-reflection in sleepTick</name>
  <files>src/memory/gardener-reflection.test.ts</files>
  <action>
    Create integration tests following the pattern from gardener-nrem.test.ts and gardener-rem.test.ts.

    **Test setup:**
    - Real SQLite database (createDatabase with :memory:)
    - ScallopMemoryStore with real DB
    - Mock fusionProvider that returns appropriate JSON for reflection prompts (distinguish reflection vs SOUL prompt by checking if prompt contains "session summaries" vs "behavioral guidelines")
    - Temporary workspace directory (use node:os tmpdir + mkdtemp) for SOUL.md I/O
    - Seed session summaries in DB using db.addSessionSummary()
    - BackgroundGardener with workspace option set

    **Tests (5-6 tests):**

    1. `should generate insights and create SOUL.md on first reflection` — Seed 2 session summaries (recent, with 5+ messages each). Run sleepTick. Verify: insight memories stored with category='insight', learnedFrom='self_reflection', memoryType='derived'. SOUL.md file exists in workspace with content from mock provider.

    2. `should update existing SOUL.md with new reflections` — Create initial SOUL.md in workspace. Seed session summaries. Run sleepTick. Verify: SOUL.md content changed (updated by mock provider). Confirm mock provider received existing SOUL content in the distillation prompt.

    3. `should skip reflection when no recent session summaries` — Seed session summaries with old timestamps (>24h ago). Run sleepTick. Verify: no insight memories created, SOUL.md not created/modified.

    4. `should skip reflection when sessions have too few messages` — Seed session summary with messageCount=1. Run sleepTick. Verify: reflection skipped.

    5. `should not affect dream cycle on reflection failure` — Mock provider that returns valid NREM/REM results but throws on reflection prompt. Seed memories for dream cycle + session summaries. Run sleepTick. Verify: NREM fused memories created (dream succeeded), no insight memories (reflection failed gracefully).

    6. `should skip reflection when no workspace configured` — Create gardener without workspace option. Seed session summaries. Run sleepTick. Verify: no insight memories, no errors.

    **Mock provider pattern:**
    ```typescript
    const mockProvider: LLMProvider = {
      name: 'mock-reflection',
      isAvailable: () => true,
      complete: vi.fn().mockImplementation(async (req) => {
        const prompt = req.messages[0]?.content ?? '';

        // Reflection prompt (generates insights)
        if (prompt.includes('Analyze these session summaries') || prompt.includes('reflecting on today')) {
          return {
            content: JSON.stringify({
              insights: [{ content: 'User prefers concise responses', topics: ['communication'] }],
              principles: ['Keep responses focused and actionable'],
            }),
            tokenUsage: { prompt: 100, completion: 50, total: 150 },
          };
        }

        // SOUL distillation prompt
        if (prompt.includes('behavioral guidelines') || prompt.includes('Re-distill')) {
          return {
            content: '# Behavioral Guidelines\n\nBe concise and actionable in all responses.',
            tokenUsage: { prompt: 100, completion: 50, total: 150 },
          };
        }

        // NREM/REM/other prompts — return appropriate defaults
        return {
          content: JSON.stringify({ summary: 'Test fusion', importance: 6, confidence: 0.8, category: 'insight' }),
          tokenUsage: { prompt: 100, completion: 50, total: 150 },
        };
      }),
    };
    ```

    **Cleanup:** Use afterEach to remove temp workspace directory (rm -rf with fs.rm).
  </action>
  <verify>npm test -- src/memory/gardener-reflection.test.ts — all 5-6 tests pass</verify>
  <done>Integration tests verify: insight storage, SOUL.md creation/update, skip behaviors, error isolation, workspace gating. All pass.</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npx tsc --noEmit` passes (no type errors)
- [ ] `npm test` passes all tests (including new reflection + gardener-reflection tests)
- [ ] SOUL.md is created when sleepTick runs with session summaries
- [ ] Insights stored as `insight` category with `learnedFrom: 'self_reflection'`
- [ ] Dream cycle unaffected by reflection (error isolation verified)
- [ ] No workspace = no reflection (graceful skip)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Self-reflection pipeline works end-to-end in sleepTick
- SOUL.md I/O verified (create + update)
- Error isolation verified (reflection failure doesn't break dreams)
- Phase 30 complete
</success_criteria>

<output>
After completion, create `.planning/phases/30-self-reflection/30-02-SUMMARY.md`
</output>
