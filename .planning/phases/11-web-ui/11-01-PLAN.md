---
phase: 11-web-ui
plan: 01
type: execute
---

<objective>
Create a local web interface for testing the agent alongside Telegram.

Purpose: Enable browser-based interaction with the agent for easier testing and debugging without needing Telegram.
Output: Working web UI at http://localhost:3000 with real-time chat via WebSocket.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context:
@.planning/phases/10-test-infrastructure/10-01-SUMMARY.md

# Key source files:
@src/channels/api.ts
@src/gateway/gateway.ts
@src/config/config.ts
@src/cli.ts

**Tech stack available:**
- Node.js HTTP server (vanilla, no Express)
- WebSocket via `ws` package
- SSE streaming support
- Existing ApiChannel with full REST + WebSocket implementation

**Established patterns:**
- Gateway creates channel instances, passes Agent + SessionManager
- Channels implement Channel interface (start/stop/isRunning/getStatus)
- Config loaded from environment variables via Zod schemas

**Constraining decisions:**
- Skills-only execution (no tool fallback)
- Gateway retains internal toolRegistry for reminder/file callbacks only
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add API channel config and wire into Gateway</name>
  <files>src/config/config.ts, src/gateway/gateway.ts</files>
  <action>
1. In config.ts, add `apiChannelSchema` to channelsSchema:
   - enabled: boolean (default false, enabled if WEB_UI_ENABLED=true)
   - port: number (default 3000, from WEB_UI_PORT)
   - host: string (default '127.0.0.1', from WEB_UI_HOST)
   - apiKey: optional string (from WEB_UI_API_KEY)

2. In gateway.ts:
   - Import ApiChannel from '../channels/api.js'
   - Add `private apiChannel: ApiChannel | null = null`
   - In start(), after Telegram channel, add API channel initialization:
     ```
     if (this.config.channels.api.enabled) {
       this.apiChannel = new ApiChannel({
         port: this.config.channels.api.port,
         host: this.config.channels.api.host,
         apiKey: this.config.channels.api.apiKey,
         agent: this.agent!,
         sessionManager: this.sessionManager!,
         logger: this.logger,
       });
       await this.apiChannel.start();
     }
     ```
   - In stop(), add cleanup for apiChannel before telegram cleanup

Do NOT add allowedOrigins config yet - we'll allow same-origin only for security.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>API channel config exists, Gateway creates ApiChannel when WEB_UI_ENABLED=true</done>
</task>

<task type="auto">
  <name>Task 2: Add static file serving to ApiChannel</name>
  <files>src/channels/api.ts</files>
  <action>
1. Add new config option: `staticDir?: string` (optional path to static files directory)

2. In handleRequest(), before the route matching:
   - If staticDir is set and path doesn't start with /api/ and isn't /ws:
   - Resolve the file path: `path.join(staticDir, path === '/' ? 'index.html' : path)`
   - Check if file exists using fs.promises.stat()
   - If exists, serve with appropriate Content-Type based on extension:
     - .html -> text/html
     - .css -> text/css
     - .js -> text/javascript
     - .json -> application/json
     - .png -> image/png
     - .svg -> image/svg+xml
     - default -> application/octet-stream
   - If file not found and path has no extension, try path + '.html'
   - Use fs.createReadStream() to pipe file to response

3. Update Gateway to pass staticDir:
   - In gateway.ts, calculate: `path.join(process.cwd(), 'public')`
   - Pass as staticDir option to ApiChannel

Security: Use path.resolve and verify the resolved path starts with staticDir to prevent directory traversal.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>ApiChannel serves static files from public/ directory, prevents path traversal</done>
</task>

<task type="auto">
  <name>Task 3: Create web chat interface</name>
  <files>public/index.html, public/style.css, public/app.js</files>
  <action>
1. Create public/ directory at project root

2. Create public/index.html:
   - Simple semantic HTML5 structure
   - Chat container with message list and input form
   - Link to style.css and app.js
   - Mobile-responsive viewport meta tag

3. Create public/style.css:
   - Clean, minimal design (dark theme preferred for dev tool)
   - Message bubbles: user messages right-aligned, assistant left-aligned
   - Fixed input bar at bottom
   - Scrollable message area
   - Loading indicator for pending responses
   - Mobile-friendly (flexbox layout)

4. Create public/app.js:
   - Connect to WebSocket at ws://localhost:PORT/ws (get port from window.location)
   - On form submit: send {type: 'chat', message: input.value}
   - On ws message: parse JSON, append to message list
   - Handle connection states (connecting, connected, disconnected)
   - Auto-reconnect on disconnect with exponential backoff
   - Auto-scroll to bottom on new messages
   - Show typing indicator while waiting for response

Keep it simple - no build tools, no frameworks, vanilla JS.
  </action>
  <verify>Files exist: `ls public/index.html public/style.css public/app.js`</verify>
  <done>Web chat UI exists with WebSocket connection, message display, and input handling</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npx tsc --noEmit` passes
- [ ] `npm test` passes (existing tests still work)
- [ ] With WEB_UI_ENABLED=true, `npm start` serves web UI at configured port
- [ ] Browser can connect via WebSocket and send/receive messages
- [ ] Static files are served correctly (index.html, CSS, JS)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- Web UI accessible at http://localhost:3000
- Chat messages round-trip through WebSocket to agent and back
</success_criteria>

<output>
After completion, create `.planning/phases/11-web-ui/11-01-SUMMARY.md`
</output>
