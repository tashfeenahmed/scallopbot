---
phase: 29-enhanced-forgetting
plan: 02
type: execute
---

<objective>
Wire utility-based archival into deepTick and add orphaned relation pruning. Replace the simple `pruneArchivedMemories(0.01)` with utility-score-driven archival that consumes the retrieval audit's `candidatesForDecay`, plus clean up orphaned relation edges.

Purpose: Complete the enhanced forgetting pipeline — utility score (Plan 01) feeds into deepTick archival decisions, and orphaned relations from deleted/superseded memories get cleaned up.
Output: deepTick uses utility-based forgetting, orphan pruning function exists, integration tests verify the pipeline.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan in this phase:
@.planning/phases/29-enhanced-forgetting/29-01-SUMMARY.md

# Prior phase context:
@.planning/phases/24-heartbeat-tier-enhancements/24-01-SUMMARY.md
@.planning/phases/28-dream-rem-exploration/28-03-SUMMARY.md

# Key source files:
@src/memory/utility-score.ts
@src/memory/decay.ts
@src/memory/retrieval-audit.ts
@src/memory/db.ts
@src/memory/memory.ts
@src/memory/index.ts

**Tech stack available:** better-sqlite3, vitest, pure functions pattern
**Established patterns:** deepTick pipeline (audit → prune → behavioral), per-operation error isolation, candidatesForDecay array from retrieval audit

**Constraining decisions:**
- Phase 24-01: candidatesForDecay provides memory IDs that are never-retrieved or stale-retrieved
- Existing pruneArchivedMemories deletes memories with prominence < 0.01 AND is_latest = 0
- New approach: archive (set is_latest=0, memory_type='superseded') memories below utility threshold THEN prune the truly dead ones
- Memory relations have FOREIGN KEY with ON DELETE CASCADE in schema, but current pruneArchivedMemories manually deletes relations first — keep manual deletion for safety since SQLite FK enforcement requires PRAGMA foreign_keys=ON which may not be set
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add orphanPruneRelations and wire utility-based forgetting into deepTick</name>
  <files>src/memory/utility-score.ts, src/memory/db.ts, src/memory/memory.ts, src/memory/index.ts</files>
  <action>
    **1. Add `pruneOrphanedRelations` to utility-score.ts:**

    ```
    pruneOrphanedRelations(db: ScallopDatabase): number
    ```
    - Query memory_relations where source_id or target_id does NOT exist in memories table
    - Delete those orphaned relations
    - Return count of deleted relations
    - Single SQL: `DELETE FROM memory_relations WHERE source_id NOT IN (SELECT id FROM memories) OR target_id NOT IN (SELECT id FROM memories)`

    **2. Add `archiveLowUtilityMemories` to utility-score.ts:**

    ```
    archiveLowUtilityMemories(db: ScallopDatabase, options?: ArchiveOptions): ArchiveResult
    ```
    ArchiveOptions: { utilityThreshold?: number (default 0.1), minAgeDays?: number (default 14), maxPerRun?: number (default 50) }
    ArchiveResult: { archived: number, ids: string[] }

    - Calls findLowUtilityMemories to get candidates
    - For each candidate (up to maxPerRun): set is_latest=0 and memory_type='superseded' via db.updateMemory()
    - Do NOT hard-delete — just archive. The existing pruneArchivedMemories in the next step handles hard deletion of very-low-prominence superseded memories.
    - Return count and IDs archived

    **3. Wire into deepTick in memory.ts:**

    Replace the current step 3 (prune old sessions + archived memories) and step 5 (retrieval audit) with an integrated pipeline:

    In deepTick, AFTER full decay scan (step 1) and AFTER session summarization (step 2):

    Step 3 (Enhanced forgetting — replaces old steps 3+5):
    ```
    // 3a. Retrieval audit (moved from step 5 to inform archival)
    const auditResult = auditRetrievalHistory(db);

    // 3b. Utility-based archival of low-utility active memories
    const archiveResult = archiveLowUtilityMemories(db, { utilityThreshold: 0.1, minAgeDays: 14, maxPerRun: 50 });

    // 3c. Hard prune truly dead memories (very low prominence + superseded)
    const sessionsDeleted = db.pruneOldSessions(30);
    const memoriesDeleted = db.pruneArchivedMemories(0.01);

    // 3d. Prune orphaned relation edges
    const orphansDeleted = pruneOrphanedRelations(db);
    ```

    Log all results in a single info log: `Enhanced forgetting complete` with auditResult summary, archiveResult.archived, memoriesDeleted, orphansDeleted.

    Remove the old step 5 (retrieval audit) since it's now in step 3a.

    Renumber subsequent steps (old step 6 trust score → new step 5, etc.)

    **4. Export new functions from index.ts:**

    Add exports for archiveLowUtilityMemories, pruneOrphanedRelations, ArchiveOptions, ArchiveResult from utility-score.ts.

    **What to avoid:**
    - Do NOT change the utility score formula (that's in Plan 01)
    - Do NOT modify decay.ts — utility score is separate from prominence
    - Do NOT hard-delete in archiveLowUtilityMemories — archive first, prune later
    - Do NOT change the pruneArchivedMemories threshold (0.01) — it handles the final cleanup
    - Do NOT use SQL transactions spanning multiple operations in deepTick — each step is independently error-isolated per established pattern
  </action>
  <verify>npx tsc --noEmit && npx vitest run src/memory/utility-score.test.ts --reporter=verbose</verify>
  <done>
    - pruneOrphanedRelations deletes dangling relation edges
    - archiveLowUtilityMemories archives memories below utility threshold
    - deepTick pipeline: audit → archive → prune → orphan cleanup
    - Old retrieval audit step removed (integrated into step 3)
    - TypeScript compiles, existing utility-score tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add integration tests for enhanced forgetting pipeline</name>
  <files>src/memory/gardener-tier3.test.ts (or new src/memory/enhanced-forgetting.test.ts)</files>
  <action>
    Create `src/memory/enhanced-forgetting.test.ts` with integration tests using real SQLite (in-memory DB, same pattern as gardener-tier3.test.ts):

    **Test 1: archiveLowUtilityMemories archives old never-accessed memories**
    - Create 3 memories: one 30 days old with 0 access, one 30 days old with 5 accesses, one 2 days old with 0 access
    - Run archiveLowUtilityMemories with default threshold
    - Assert: only the 30-day-old zero-access memory is archived (is_latest=0, memory_type='superseded')
    - The 2-day-old is protected by minAgeDays, the 5-access one has utility above threshold

    **Test 2: pruneOrphanedRelations cleans up dangling edges**
    - Create 2 memories and a relation between them
    - Delete one memory via db.deleteMemory()
    - Run pruneOrphanedRelations
    - Assert: relation is deleted, returns count 1

    **Test 3: pruneOrphanedRelations returns 0 when no orphans**
    - Create 2 memories with a relation
    - Run pruneOrphanedRelations
    - Assert: returns 0, relation still exists

    **Test 4: archiveLowUtilityMemories respects maxPerRun**
    - Create 10 old zero-access memories
    - Run with maxPerRun: 3
    - Assert: exactly 3 archived

    **Test 5: static_profile memories are never archived**
    - Create a static_profile memory that's old with 0 access
    - Run archiveLowUtilityMemories
    - Assert: not archived (findLowUtilityMemories excludes static_profile)

    **Test 6: Full pipeline smoke test (deepTick-style)**
    - Create a mix of memories: some old/unused, some with access, some with orphaned relations
    - Call auditRetrievalHistory, then archiveLowUtilityMemories, then pruneOrphanedRelations
    - Assert: correct memories archived, correct orphans cleaned, healthy memories untouched

    Follow the existing test patterns: use createDatabase(':memory:'), real DB operations, no mocks for DB layer.
  </action>
  <verify>npx vitest run src/memory/enhanced-forgetting.test.ts --reporter=verbose</verify>
  <done>
    - 6 integration tests passing
    - All existing memory tests still pass (npx vitest run src/memory/ --reporter=verbose)
    - No regressions
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes
- [ ] `npx vitest run src/memory/utility-score.test.ts` passes (Plan 01 tests)
- [ ] `npx vitest run src/memory/enhanced-forgetting.test.ts` passes (Plan 02 tests)
- [ ] `npx vitest run src/memory/` passes (all memory module tests, 460+)
- [ ] deepTick logs "Enhanced forgetting complete" with audit, archive, prune, orphan counts
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- deepTick uses utility-based archival instead of just prominence-threshold pruning
- Retrieval audit candidatesForDecay is consumed (audit moved before archival)
- Orphaned relations are cleaned up
- Phase 29 complete
</success_criteria>

<output>
After completion, create `.planning/phases/29-enhanced-forgetting/29-02-SUMMARY.md`:

# Phase 29 Plan 2: Wire Utility Forgetting + Orphan Pruning Summary

**[Substantive one-liner]**

## Accomplishments
## Files Created/Modified
## Decisions Made
## Issues Encountered
## Next Step

Phase 29 complete, ready for Phase 30: Self-Reflection
</output>
