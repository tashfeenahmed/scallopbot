---
phase: 29-enhanced-forgetting
plan: 01
type: tdd
---

<objective>
Implement utility score computation — the core formula that replaces simple prominence-threshold pruning with access-history-weighted utility scoring per Hu et al.

Purpose: `utilityScore = prominence × log(1 + accessCount)` gives a single metric combining memory freshness (prominence) with actual usefulness (retrieval frequency). Memories with high prominence but zero access get low utility; frequently-accessed memories get boosted.
Output: Pure function `computeUtilityScore()` with comprehensive tests, plus `findLowUtilityMemories()` that queries DB for memories below a utility threshold.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context (auto-selected from dependency graph):
@.planning/phases/24-heartbeat-tier-enhancements/24-01-SUMMARY.md
@.planning/phases/28-dream-rem-exploration/28-03-SUMMARY.md

# Key source files:
@src/memory/decay.ts
@src/memory/retrieval-audit.ts
@src/memory/db.ts

**Tech stack available:** better-sqlite3, vitest, pure functions pattern
**Established patterns:** Stateless pure functions (from v3.0), age-gated audit (from Phase 24), TDD red-green-refactor cycle

**Constraining decisions:**
- Phase 24-01: "Audit-only: no mutation in retrieval audit — Phase 29 consumes candidatesForDecay"
- Roadmap formula: `utilityScore = prominence × log(1 + accessCount)`
- DecayEngine already uses accessCount in prominence calculation — utility score is a SEPARATE metric for deletion decisions, not a replacement for prominence
</context>

<feature>
  <name>Utility Score Computation</name>
  <files>src/memory/utility-score.ts, src/memory/utility-score.test.ts</files>
  <behavior>
    Core formula: `utilityScore = prominence × log(1 + accessCount)`

    computeUtilityScore(prominence: number, accessCount: number): number
    - prominence=0.5, accessCount=0 → 0.5 × log(1) = 0.0
    - prominence=0.5, accessCount=1 → 0.5 × log(2) ≈ 0.347
    - prominence=0.8, accessCount=5 → 0.8 × log(6) ≈ 1.433
    - prominence=0.0, accessCount=100 → 0.0 (zero prominence = zero utility regardless of access)
    - prominence=1.0, accessCount=0 → 0.0 (never accessed = zero utility regardless of prominence)
    - prominence=0.3, accessCount=3 → 0.3 × log(4) ≈ 0.416

    Note: Use Math.log (natural log) per standard information-theoretic usage.

    findLowUtilityMemories(db: ScallopDatabase, options?: FindLowUtilityOptions): LowUtilityMemory[]
    Options: { utilityThreshold?: number (default 0.1), minAgeDays?: number (default 14), maxResults?: number (default 100), excludeTypes?: ScallopMemoryType[] }
    - Queries active memories (is_latest=1, prominence > 0) older than minAgeDays
    - Computes utility score for each
    - Returns those below utilityThreshold, sorted by utility ascending (lowest first)
    - Always excludes static_profile type
    - Returns id, content (truncated to 80 chars for logging), prominence, accessCount, utilityScore, category, ageDays

    Edge cases:
    - Empty DB → empty array
    - All memories above threshold → empty array
    - Respects minAgeDays (no false positives on new memories — same pattern as retrieval audit)
  </behavior>
  <implementation>
    Create src/memory/utility-score.ts as a pure-function module (no class, following v3.0 pattern).

    computeUtilityScore is a pure arithmetic function — no DB dependency.

    findLowUtilityMemories does a single SQL query fetching id, prominence, access_count, category, memory_type, document_date, content from memories WHERE is_latest=1 AND memory_type != 'static_profile' AND document_date < ageCutoff, then computes utility in JS and filters/sorts.

    Export LowUtilityMemory interface and FindLowUtilityOptions interface.

    Do NOT modify decay.ts — utility score is a separate concern for deletion decisions, not part of the decay calculation.
  </implementation>
</feature>

<verification>
npx vitest run src/memory/utility-score.test.ts --reporter=verbose
</verification>

<success_criteria>
- Failing tests written and committed (RED)
- computeUtilityScore passes all edge cases
- findLowUtilityMemories correctly queries DB and filters
- All commits present (test → feat → optional refactor)
- Existing 458+ memory tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/29-enhanced-forgetting/29-01-SUMMARY.md`
</output>
