---
phase: 07-agent-loop-refactor
plan: 02
type: execute
---

<objective>
Generate tool definitions from skills and execute skills when LLM requests tool calls.

Purpose: The LLM uses the tool_use protocol to invoke capabilities. This plan bridges skills to that protocol by generating ToolDefinition objects from skills and routing tool_use requests to skill execution via SkillExecutor.
Output: Agent uses skill-based tool definitions and executes skills through SkillExecutor.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan in this phase
@.planning/phases/07-agent-loop-refactor/07-01-PLAN.md

# Prior phase summaries
@.planning/phases/01-skill-system-foundation/01-01-SUMMARY.md
@.planning/phases/03-skill-executor/03-01-SUMMARY.md

# Source files
@src/agent/agent.ts
@src/skills/registry.ts
@src/skills/executor.ts
@src/skills/types.ts
@src/providers/types.ts

**Tech stack available:** SkillRegistry, SkillExecutor, ToolDefinition interface
**Established patterns:**
- SkillExecutor.execute(skill, request) runs skill scripts
- ToolDefinition has name, description, input_schema
- Skills have inputSchema in frontmatter (from 07-01)
**Constraining decisions:**
- SKILL_ARGS env var for passing arguments as JSON
- Skills return JSON via stdout
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getToolDefinitions() to SkillRegistry</name>
  <files>src/skills/registry.ts</files>
  <action>
Add a method to SkillRegistry that generates ToolDefinition[] from available skills.

```typescript
import type { ToolDefinition } from '../providers/types.js';

// In SkillRegistry class:
getToolDefinitions(): ToolDefinition[] {
  const skills = this.getModelSkills(); // Skills not disabled for model invocation
  return skills.map(skill => ({
    name: skill.name,
    description: skill.description,
    input_schema: skill.frontmatter.inputSchema || {
      type: 'object' as const,
      properties: {},
      required: [],
    },
  }));
}
```

For skills without inputSchema, provide an empty schema (no required parameters).

This bridges skills to the LLM tool protocol - skills become "tools" from the LLM's perspective.
  </action>
  <verify>npm run build succeeds, new method exists on SkillRegistry</verify>
  <done>SkillRegistry.getToolDefinitions() returns ToolDefinition[] for all model skills</done>
</task>

<task type="auto">
  <name>Task 2: Update Agent to use skill-based tool definitions</name>
  <files>src/agent/agent.ts</files>
  <action>
Replace toolRegistry.getToolDefinitions() with skillRegistry.getToolDefinitions() in the agent loop.

In processMessage(), around line 320-323, change:
```typescript
// OLD
const registry = this.toolRegistry as any;
const tools = typeof registry.getFilteredToolDefinitions === 'function'
  ? registry.getFilteredToolDefinitions()
  : this.toolRegistry.getToolDefinitions();

// NEW
const tools = this.skillRegistry
  ? this.skillRegistry.getToolDefinitions()
  : [];
```

This means the LLM will see skills as tools. When it requests "tool_use" for "bash", we'll execute the bash skill.

Do NOT change executeTools() yet - that's Task 3.
  </action>
  <verify>npm run build succeeds, Agent.processMessage() uses skillRegistry for tool definitions</verify>
  <done>Agent uses skillRegistry.getToolDefinitions() for LLM tool definitions</done>
</task>

<task type="auto">
  <name>Task 3: Execute skills via SkillExecutor in agent loop</name>
  <files>src/agent/agent.ts</files>
  <action>
Replace tool execution with skill execution in executeTools().

1. Add SkillExecutor import and instance:
   ```typescript
   import { SkillExecutor } from '../skills/executor.js';
   ```

2. Add skillExecutor to AgentOptions and constructor:
   ```typescript
   interface AgentOptions {
     // ... existing
     skillExecutor?: SkillExecutor;
   }

   private skillExecutor: SkillExecutor | null;

   constructor(options: AgentOptions) {
     // ... existing
     this.skillExecutor = options.skillExecutor || null;
   }
   ```

3. Replace executeTools() logic to use skills:
   ```typescript
   private async executeTools(
     toolUses: ToolUseContent[],
     sessionId: string,
     userId?: string
   ): Promise<ContentBlock[]> {
     const results: ContentBlock[] = [];

     for (const toolUse of toolUses) {
       // Try skill first
       const skill = this.skillRegistry?.getSkill(toolUse.name);

       if (skill && this.skillExecutor) {
         this.logger.debug({ skillName: toolUse.name, input: toolUse.input }, 'Executing skill');

         try {
           const result = await this.skillExecutor.execute(skill, {
             args: toolUse.input,
             cwd: this.workspace,
           });

           results.push({
             type: 'tool_result',
             tool_use_id: toolUse.id,
             content: result.success
               ? (result.output || 'Success')
               : `Error: ${result.error}`,
             is_error: !result.success,
           });

           // Collect in memory
           if (this.hotCollector && result.success) {
             this.hotCollector.collect({
               content: `Skill ${toolUse.name} executed: ${(result.output || '').slice(0, 500)}`,
               sessionId,
               source: `skill:${toolUse.name}`,
               tags: ['skill-execution', toolUse.name],
               metadata: { skillInput: toolUse.input },
             });
           }
         } catch (error) {
           const err = error as Error;
           this.logger.error({ skillName: toolUse.name, error: err.message }, 'Skill execution failed');
           results.push({
             type: 'tool_result',
             tool_use_id: toolUse.id,
             content: `Error executing skill: ${err.message}`,
             is_error: true,
           });
         }
         continue;
       }

       // Fallback to tool (for backward compatibility during transition)
       const tool = this.toolRegistry?.getTool(toolUse.name);
       if (tool) {
         // ... existing tool execution logic
       } else {
         this.logger.warn({ name: toolUse.name }, 'Unknown skill/tool requested');
         results.push({
           type: 'tool_result',
           tool_use_id: toolUse.id,
           content: `Error: Unknown skill "${toolUse.name}"`,
           is_error: true,
         });
       }
     }

     return results;
   }
   ```

Keep the tool fallback for now - 07-03 will clean it up.
  </action>
  <verify>npm run build succeeds, Agent routes tool_use to skill execution when skill exists</verify>
  <done>Agent executes skills via SkillExecutor, falls back to tools for unknown skills</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] SkillRegistry.getToolDefinitions() returns valid ToolDefinition[]
- [ ] Agent.processMessage() uses skill-based tool definitions
- [ ] Agent.executeTools() routes to skill execution when skill exists
- [ ] Fallback to toolRegistry works for backward compatibility
</verification>

<success_criteria>

- Skills generate ToolDefinition objects for LLM
- Agent uses skill definitions in LLM requests
- Skill execution via SkillExecutor in agent loop
- All verification checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-agent-loop-refactor/07-02-SUMMARY.md`
</output>
