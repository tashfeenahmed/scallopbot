---
phase: 21-memory-fusion-engine
plan: 02
type: execute
---

<objective>
Wire the fusion engine into BackgroundGardener's deep tick and add integration tests proving end-to-end memory fusion through ScallopMemoryStore.

Purpose: Connect the pure fusion functions (Plan 01) to the actual memory system so clusters of decaying memories are automatically fused every ~6 hours.
Output: Fusion integrated into deep tick, opt-in fusionProvider in gardener options, integration tests validating full pipeline.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-memory-fusion-engine/21-RESEARCH.md
@.planning/phases/21-memory-fusion-engine/21-01-SUMMARY.md

# Key source files:
@src/memory/fusion.ts
@src/memory/fusion.test.ts
@src/memory/memory.ts
@src/memory/scallop-store.ts
@src/memory/db.ts
@src/memory/relations.ts
@src/memory/scallop.test.ts

**Tech stack available:** vitest, ScallopDatabase, DecayEngine, RelationGraph, ScallopMemoryStore, findFusionClusters, fuseMemoryCluster
**Established patterns:**
- Opt-in provider injection via constructor options (rerankProvider, relationsProvider, activationConfig)
- Provider reuse: same fast-tier provider serves multiple LLM features
- Integration tests with mock LLMProvider and deterministic embedders

**Constraining decisions:**
- [Phase 18-02]: Opt-in rerankProvider via constructor, existing behavior unchanged without it
- [Phase 19-02]: Reuse rerankProvider as relationsProvider — both need fast/cheap LLM
- [Phase 20-02]: ActivationConfig opt-in via ScallopMemoryStoreOptions constructor
- [RESEARCH]: Fusion in deepTick AFTER full decay, BEFORE pruning. Cap at 5 clusters. Store fused as derived with DERIVES relations. Mark sources as superseded. sourceChunk with source content for BM25.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire fusion into BackgroundGardener deep tick</name>
  <files>src/memory/memory.ts, src/memory/scallop-store.ts, src/memory/index.ts</files>
  <action>
    **1. BackgroundGardenerOptions** — Add optional `fusionProvider?: LLMProvider` field. Same opt-in pattern as rerankProvider.

    **2. BackgroundGardener constructor** — Store fusionProvider. No changes if not provided.

    **3. BackgroundGardener.deepTick()** — After full decay scan (step 1) and BEFORE session summaries (step 2), add fusion step:
    - If `this.fusionProvider` is set:
      - Get all users with memories (query distinct user_id from memories table)
      - For each user: get dormant memories via `db.getMemoriesByUser(userId, { minProminence: 0.1, isLatest: true, includeAllSources: true })`, then filter in JS for prominence < 0.5 and memoryType not in ['static_profile', 'derived']
      - Call `findFusionClusters(dormantMemories, (id) => db.getRelations(id), { minClusterSize: 3, maxClusters: 5 })`
      - For each cluster: call `fuseMemoryCluster(cluster, this.fusionProvider)`
      - If fusion result is not null: store fused memory and mark sources
    - Store fused memory via `this.scallopStore.add()` with: `memoryType: 'derived'`, `learnedFrom: 'consolidation'`, `category: result.category`, `importance: result.importance`, `confidence: result.confidence`, `sourceChunk: cluster.map(m => m.content).join(' | ')`, `metadata: { fusedAt: ISO date, sourceCount, sourceIds }`, `detectRelations: false`
    - Add DERIVES relation from fused memory to each source via `db.addRelation(fusedId, sourceId, 'DERIVES', 0.95)`
    - Mark each source: `this.scallopStore.update(sourceId, { isLatest: false })` and set memoryType to 'superseded' via `db.updateMemoryType(sourceId, 'superseded')` — if this method doesn't exist, use raw SQL `UPDATE memories SET memory_type = 'superseded' WHERE id = ?`
    - Set fused memory prominence to `Math.min(0.6, Math.max(...cluster.map(m => m.prominence)) + 0.1)` via `db.updateProminences([{ id: fusedId, prominence }])`
    - Log results: `{ fused: clustersFused, memoriesMerged: totalSourceMemories }`
    - Wrap entire fusion block in try/catch — log warning on failure, never break deep tick

    **4. Gateway integration** — In `src/gateway/gateway.ts` where BackgroundGardener is constructed, pass `fusionProvider` reusing the same fast-tier provider used for rerankProvider/relationsProvider (the pattern from Phase 19-02). If no fast-tier provider available, don't pass fusionProvider (fusion disabled).

    **5. Re-export** — Export FusionConfig and FusionResult from `src/memory/index.ts`.

    **What to avoid:**
    - Do NOT make fusionProvider mandatory — gardener must work without it (existing behavior unchanged)
    - Do NOT process users in parallel — sequential to avoid SQLite contention
    - Do NOT delete source memories — only mark as superseded and isLatest=false
    - Do NOT run fusion on light tick — only deep tick (every ~6 hours)
  </action>
  <verify>npx tsc --noEmit passes, no type errors. Manual review: deepTick has fusion step after decay and before session summaries.</verify>
  <done>BackgroundGardener accepts optional fusionProvider. Deep tick fuses dormant memory clusters when provider is set. Gateway passes fast-tier provider. No behavior change when fusionProvider absent.</done>
</task>

<task type="auto">
  <name>Task 2: Add integration tests for memory fusion pipeline</name>
  <files>src/memory/scallop.test.ts</files>
  <action>
    Add a new `describe('Scenario: Memory fusion in deep tick')` block in scallop.test.ts following existing test patterns (deterministic embedder, mock LLM provider, cleanup).

    **Test 1: "should fuse cluster of dormant related memories during deep tick"**
    - Setup: Create ScallopMemoryStore with test embedder. Create 4 memories with same category ('fact'), same userId, all with prominence manually set to 0.3 (dormant range). Add EXTENDS relations connecting them (creating one connected component).
    - Create BackgroundGardener with fusionProvider (mock LLM that returns valid fusion JSON).
    - Action: Call `gardener.deepTick()`.
    - Assert: A new `derived` memory exists with `learnedFrom: 'consolidation'`. Source memories now have `isLatest: false`. DERIVES relations exist from fused to sources. Fused memory's sourceChunk contains source content.

    **Test 2: "should not fuse active or derived memories"**
    - Setup: Create memories — some with prominence 0.7 (active), some with memoryType 'derived', some valid dormant. Add relations.
    - Action: Call `gardener.deepTick()`.
    - Assert: Only the valid dormant cluster was fused. Active and derived memories untouched.

    **Test 3: "should handle LLM fusion failure gracefully"**
    - Setup: Create valid dormant cluster. Mock LLM that throws error.
    - Action: Call `gardener.deepTick()`.
    - Assert: No crash, no fused memories created, source memories unchanged, deep tick completes normally (session summaries, pruning still run).

    Follow existing test patterns:
    - Use `cleanup()` in beforeEach
    - Use deterministic test embedder (word-presence vectors)
    - Use mock LLM with sequential canned responses
    - Set prominence via `db.updateProminences()` after initial add
  </action>
  <verify>npx vitest run src/memory/scallop.test.ts --reporter=verbose — all tests pass including new fusion tests</verify>
  <done>3 integration tests validate: happy path fusion, exclusion of active/derived, graceful LLM failure handling. All existing tests still pass.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` — no type errors
- [ ] `npx vitest run src/memory/fusion.test.ts` — all unit tests pass
- [ ] `npx vitest run src/memory/scallop.test.ts` — all integration tests pass (including new fusion tests)
- [ ] No regressions in existing tests
- [ ] Fusion only runs during deep tick, only when fusionProvider is set
- [ ] Source memories preserved as superseded (not deleted)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Fusion pipeline works end-to-end: deep tick → find clusters → LLM fuse → store derived → mark sources superseded
- Existing behavior completely unchanged when fusionProvider not provided
- Phase 21 complete (2/2 plans done)
</success_criteria>

<output>
After completion, create `.planning/phases/21-memory-fusion-engine/21-02-SUMMARY.md`
</output>
