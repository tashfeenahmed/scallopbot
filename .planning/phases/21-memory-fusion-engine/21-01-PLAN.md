---
phase: 21-memory-fusion-engine
plan: 01
type: tdd
---

<objective>
Implement core memory fusion engine: cluster detection and LLM-guided content merging as pure, testable functions.

Purpose: Create the algorithmic core that finds clusters of decaying related memories and merges them into consolidated summaries — the "brain" of the fusion engine, separate from gardener integration.
Output: `src/memory/fusion.ts` with `findFusionClusters()` and `fuseMemoryCluster()`, fully tested via TDD.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/tdd.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-memory-fusion-engine/21-RESEARCH.md

# Auto-selected based on dependency graph:
@.planning/phases/20-spreading-activation/20-02-SUMMARY.md
@.planning/phases/19-llm-guided-relations/19-02-SUMMARY.md
@.planning/phases/18-retrieval-reranking/18-01-SUMMARY.md

# Key source files:
@src/memory/relations.ts
@src/memory/decay.ts
@src/memory/db.ts
@src/memory/memory.ts
@src/memory/fact-extractor.ts
@src/memory/relation-classifier.ts
@src/memory/scallop-store.ts
@src/memory/reranker.ts

**Tech stack available:** vitest, ScallopDatabase, DecayEngine, RelationGraph, RelationshipClassifier, ScallopMemoryStore
**Established patterns:**
- Stateless pure functions for LLM-augmented features (reranker, spreadActivation)
- Optional LLM provider injection with graceful fallback
- Score blending and JSON response parsing
- Deterministic test embedders for predictable tests

**Constraining decisions:**
- [Phase 18]: Stateless pure functions, graceful fallback on LLM failure
- [Phase 19]: Optional classifierProvider, regex fallback when absent
- [Phase 20]: Pure function spreadActivation() with callback — stateless, testable
- [RESEARCH]: Don't fuse across categories, don't fuse derived/static memories, cap clusters per tick, keep source memories as superseded

**Prior research decisions to honor:**
- Skip derived memories as fusion candidates (prevent recursive fusion)
- Same-category only fusion (prevent incoherent summaries)
- Source memories marked superseded, not deleted (prevent information loss)
- sourceChunk populated with source content for BM25 matching (prevent embedding mismatch)
</context>

<feature>
  <name>Memory Fusion Engine Core</name>
  <files>src/memory/fusion.ts, src/memory/fusion.test.ts</files>
  <behavior>
    **findFusionClusters(memories, getRelations, options)**
    - Input: array of ScallopMemoryEntry, getRelations callback (same pattern as spreadActivation), options with minClusterSize and maxClusters
    - Filters: only isLatest=true, only prominence in [DORMANT..ACTIVE) range (0.1 to 0.5), exclude static_profile and derived memoryTypes
    - Uses BFS via getRelations callback to find connected components
    - Only clusters memories within the same category
    - Returns clusters sorted by size descending, capped at maxClusters
    - Returns empty array if no clusters meet minClusterSize threshold

    Cases:
    - 3 related facts in dormant range → returns 1 cluster of 3
    - 2 related facts (below minClusterSize=3) → returns empty array
    - Mixed categories in connected component → splits into per-category sub-clusters
    - Active memories (prominence ≥ 0.5) excluded even if related
    - Derived memories excluded even if in dormant range
    - No relations → no clusters (singletons excluded)
    - 10 clusters found, maxClusters=5 → returns top 5 by size

    **fuseMemoryCluster(cluster, provider, options?)**
    - Input: array of ScallopMemoryEntry (the cluster), LLMProvider
    - Builds fusion prompt listing all memory contents with categories and importance
    - Calls LLM to produce merged summary
    - Returns { summary, importance (max of sources), category (most common), confidence (min of sources) }
    - On LLM failure: returns null (caller decides what to do)
    - Validates summary is shorter than combined source content

    Cases:
    - 3 facts about Dublin → fused summary mentioning all facts
    - LLM returns invalid JSON → returns null
    - LLM call throws → returns null
    - Empty cluster → returns null
    - Summary longer than combined sources → returns null (validation)

    **FusionConfig interface**
    - minClusterSize: number (default 3)
    - maxClusters: number (default 5)
    - minProminence: number (default PROMINENCE_THRESHOLDS.DORMANT = 0.1)
    - maxProminence: number (default PROMINENCE_THRESHOLDS.ACTIVE = 0.5)
  </behavior>
  <implementation>
    Create `src/memory/fusion.ts` with:

    1. **FusionConfig** interface with defaults via `DEFAULT_FUSION_CONFIG` const
    2. **FusionResult** interface: `{ summary: string; importance: number; category: MemoryCategory; confidence: number }`
    3. **findFusionClusters()** — pure function, takes memories array + getRelations callback (same pattern as spreadActivation). Filters by prominence range, excludes static_profile/derived, BFS for connected components, splits by category, filters by minClusterSize, sorts by size desc, caps at maxClusters
    4. **fuseMemoryCluster()** — async pure function, takes cluster + LLMProvider. Builds prompt (follow consolidateMemory pattern from fact-extractor.ts), parses JSON response, validates summary length, returns FusionResult or null
    5. **buildFusionPrompt()** — exported for testing (same pattern as buildRerankPrompt)

    Key design decisions:
    - Pure functions with callbacks, NOT class — matches reranker.ts and spreadActivation patterns
    - getRelations callback type: `(memoryId: string) => MemoryRelation[]` — same as spreadActivation
    - No DB access in fusion.ts — caller provides memories and getRelations callback
    - LLMProvider passed as argument, not constructor injection — matches reranker pattern
    - Graceful null return on any LLM error — caller decides fallback behavior
  </implementation>
</feature>

<verification>
npx vitest run src/memory/fusion.test.ts --reporter=verbose
All tests pass, covering:
- Cluster detection with various topologies
- Category-boundary enforcement
- Prominence range filtering
- LLM fusion happy path
- LLM failure graceful handling
- Prompt construction
</verification>

<success_criteria>
- findFusionClusters() correctly identifies connected components of dormant same-category memories
- fuseMemoryCluster() produces valid FusionResult from LLM response
- Both functions handle edge cases gracefully (empty input, no clusters, LLM failure)
- Pure function pattern maintained (no DB/store coupling)
- All tests pass
- 2-3 TDD commits present (test → feat → optional refactor)
</success_criteria>

<output>
After completion, create `.planning/phases/21-memory-fusion-engine/21-01-SUMMARY.md`
</output>
