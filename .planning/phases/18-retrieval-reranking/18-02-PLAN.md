---
phase: 18-retrieval-reranking
plan: 02
type: execute
---

<objective>
Integrate the LLM re-ranker into the search pipeline and memory_search skill.

Purpose: Wire the tested rerankResults() into scallop-store.ts hybrid search and the standalone memory_search skill so all search paths benefit from LLM re-ranking.
Output: Re-ranked search results in both agent context injection and skill-based search.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-retrieval-reranking/18-01-SUMMARY.md

# Key source files:
@src/memory/scallop-store.ts
@src/memory/reranker.ts
@src/memory/bm25.ts
@src/skills/bundled/memory_search/scripts/run.ts
@src/agent/agent.ts
@src/providers/types.ts
@src/routing/router.ts

**Tech stack available:** Vitest, TypeScript, LLMProvider, rerankResults()
**Established patterns:**
- ScallopMemoryStore takes options including embedder in constructor
- Search pipeline: candidates → BM25+semantic scoring → sort → limit → related memories → record access
- memory_search skill runs standalone with its own DB connection and embedder setup
- Agent gets provider via Router.selectProvider(tier)
**Constraining decisions:**
- Re-ranker uses fast tier (Groq) to minimize cost — re-ranking is a simple scoring task
- Re-ranking is opt-in via constructor option to avoid breaking existing behavior
- Fallback to original scores if no provider available or LLM fails
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add re-ranking to ScallopMemoryStore search pipeline</name>
  <files>src/memory/scallop-store.ts</files>
  <action>
    1. Add optional `rerankProvider?: LLMProvider` to ScallopMemoryStoreOptions
    2. Store it as `this.rerankProvider` in constructor
    3. In the `search()` method, after sorting by score and slicing to `limit`, add re-ranking step:
       - If `this.rerankProvider` is set and results.length > 0:
         - Map results to RerankCandidate[] (id, content, originalScore from result.score)
         - Call `rerankResults(query, candidates, this.rerankProvider, { maxCandidates: 20 })`
         - Map re-ranked results back: update each ScallopSearchResult's score to the finalScore
         - Re-sort by new score
         - Drop results with finalScore < 0.05
       - If rerankProvider is not set, keep existing behavior unchanged
    4. Add import for rerankResults from './reranker.js'

    Insert the re-ranking step BEFORE adding related memories and recording access (lines ~420-428 in current code), so only truly relevant results get their access recorded and relations fetched.

    DO NOT:
    - Change the existing BM25+semantic scoring — re-ranking augments the pipeline
    - Change SEARCH_WEIGHTS — those remain for the initial scoring pass
    - Make re-ranking blocking on construction — it's optional
    - Re-rank more than the limit — only re-rank the top N results already selected
  </action>
  <verify>npm run build (TypeScript compiles without errors)</verify>
  <done>ScallopMemoryStore.search() applies LLM re-ranking when rerankProvider is set, falls back to original behavior when not set</done>
</task>

<task type="auto">
  <name>Task 2: Wire rerankProvider in gateway/agent initialization and memory_search skill</name>
  <files>src/gateway/gateway.ts, src/skills/bundled/memory_search/scripts/run.ts</files>
  <action>
    1. In gateway.ts (or wherever ScallopMemoryStore is instantiated):
       - After router is initialized, get a fast-tier provider via `router.selectProvider('fast')`
       - Pass it as `rerankProvider` to ScallopMemoryStore constructor
       - If no fast provider available, omit rerankProvider (graceful degradation)

    2. In memory_search skill (run.ts):
       - After the existing search scoring loop, add an optional re-ranking pass
       - Try to create a lightweight LLM provider for re-ranking:
         - Check for GROQ_API_KEY env var → create minimal Groq completion call
         - If no API key available, skip re-ranking (keep existing behavior)
       - Call rerankResults() with the search results
       - Import rerankResults from the reranker module

    The skill needs a minimal LLM call capability. Rather than importing the full provider system, create a small inline adapter:
    ```
    const rerankProvider: LLMProvider = {
      name: 'groq-rerank',
      complete: async (req) => { /* fetch to Groq API */ }
    };
    ```
    This keeps the skill self-contained (it's a standalone script).

    DO NOT:
    - Import the full routing system into the skill — skills are standalone
    - Make re-ranking mandatory — always gracefully degrade
    - Add new env vars — reuse existing GROQ_API_KEY
  </action>
  <verify>npm run build && npm test -- src/memory/scallop.test.ts</verify>
  <done>
    - Gateway passes rerankProvider to ScallopMemoryStore when fast-tier provider available
    - memory_search skill applies re-ranking when GROQ_API_KEY is available
    - Both paths gracefully degrade when no provider available
  </done>
</task>

<task type="auto">
  <name>Task 3: Add integration test for re-ranked search</name>
  <files>src/memory/scallop.test.ts</files>
  <action>
    Add a describe block "search with re-ranking" to the existing scallop.test.ts:

    1. Create a mock LLMProvider that returns predictable relevance scores
    2. Test: "should re-order results based on LLM relevance scores"
       - Store 5 memories with known BM25/semantic scores
       - Mock LLM to score them in different order than BM25
       - Verify final order matches LLM preference
    3. Test: "should fall back to original scores when LLM fails"
       - Mock LLM to throw error
       - Verify results returned with original scores
    4. Test: "should skip re-ranking when no rerankProvider set"
       - Create store without rerankProvider
       - Verify search works as before

    Use the existing mock patterns from scallop.test.ts (mock logger, in-memory DB).
  </action>
  <verify>npm test -- src/memory/scallop.test.ts</verify>
  <done>3 integration tests pass, covering: re-ordering, LLM failure fallback, no-provider passthrough</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm test -- src/memory/reranker.test.ts` passes (from plan 01)
- [ ] `npm test -- src/memory/scallop.test.ts` passes (including new re-ranking tests)
- [ ] `npm test` passes (no regressions)
- [ ] Re-ranking is opt-in — existing behavior unchanged when rerankProvider not set
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors or test regressions
- Re-ranking integrates cleanly into search pipeline
- Graceful fallback when LLM unavailable
- Phase 18 complete
</success_criteria>

<output>
After completion, create `.planning/phases/18-retrieval-reranking/18-02-SUMMARY.md`
</output>
