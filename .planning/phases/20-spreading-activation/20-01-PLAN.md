---
phase: 20-spreading-activation
plan: 01
type: tdd
---

<objective>
Implement spreading activation algorithm for memory graph traversal, replacing unranked BFS with scored, decay-weighted activation propagation.

Purpose: The current `getRelatedMemoriesForContext` uses BFS which returns all reachable memories without scoring. Spreading activation produces relevance scores that decay with graph distance, enabling ranked retrieval of related memories. This is a core cognitive-science algorithm (ACT-R/SYNAPSE) that improves retrieval quality.
Output: Working, tested `spreadActivation()` function and `getRelatedMemoriesWithActivation()` method on RelationGraph, with typed edge weights, fan-out normalization, and Gaussian noise for retrieval diversity.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-spreading-activation/20-RESEARCH.md

# Key source files:
@src/memory/relations.ts
@src/memory/relations.test.ts
@src/memory/db.ts

# Auto-selected based on dependency graph:
@.planning/phases/18-retrieval-reranking/18-01-SUMMARY.md
@.planning/phases/19-llm-guided-relations/19-01-SUMMARY.md
@.planning/phases/19-llm-guided-relations/19-02-SUMMARY.md

**Tech stack available:** Vitest for testing, TypeScript, no external deps needed
**Established patterns:** Stateless pure functions with graceful fallback, opt-in provider injection, mock-based unit testing
**Constraining decisions:**
- Phase 18: Stateless pure functions pattern (rerankResults)
- Phase 19: RelationGraph as the class that owns graph operations
- Score blending pattern: compose multiple signals multiplicatively
</context>

<feature>
  <name>Spreading activation for memory graph traversal</name>
  <files>src/memory/relations.ts, src/memory/relations.test.ts</files>
  <behavior>
    Core function: `spreadActivation(seedId, getRelations, config) → Map<string, number>`

    Behavior cases:
    - Single seed node with no neighbors → empty map (seed excluded from results)
    - Seed with 1 direct neighbor → neighbor gets activation = 1.0 * edgeWeight * decayFactor / 1
    - Seed with 3 neighbors → each gets activation divided by fan-out (degree=3)
    - 2-hop propagation → neighbor's neighbor gets reduced activation (decay * decay)
    - Multiple paths converge → activation accumulates but clamps to 1.0
    - UPDATES edge type → forward=0.9, reverse=0.9 (strong bidirectional)
    - EXTENDS edge type → forward=0.7, reverse=0.5 (extension more informative)
    - DERIVES edge type → forward=0.4, reverse=0.6 (sources more relevant)
    - Edge weight multiplied by confidence field from MemoryRelation
    - Gaussian noise (sigma=0.2) applied multiplicatively to final scores
    - Noise sigma=0 → deterministic results
    - Results filtered by threshold (default 0.05)
    - Results limited to maxResults (default 10)
    - Activation below threshold (0.01) stops propagating

    Wrapper method: `getRelatedMemoriesWithActivation(memoryId, config?) → ScallopMemoryEntry[]`
    - Calls spreadActivation with db.getRelations
    - Multiplies activation by memory.prominence (temporal × spatial relevance)
    - Filters to isLatest memories only
    - Returns sorted by final score descending, limited to maxResults
    - Falls back to existing getRelatedMemoriesForContext on any error
  </behavior>
  <implementation>
    1. Add ActivationConfig interface with defaults: maxSteps=3, decayFactor=0.5, activationThreshold=0.01, retention=(1-decayFactor), noiseSigma=0.2, resultThreshold=0.05, maxResults=10
    2. Add EDGE_WEIGHTS constant: Record<RelationType, {forward, reverse}> per research
    3. Add getEdgeWeight(relation, fromId) helper
    4. Add gaussianNoise(sigma) using Box-Muller transform
    5. Add spreadActivation() as pure function — synchronous double-buffered propagation
    6. Add getRelatedMemoriesWithActivation() method on RelationGraph
    7. Do NOT remove getRelatedMemoriesForContext — it's used as fallback and will be replaced in 20-02

    Follow research code examples closely. Do NOT hand-roll custom scoring — use ACT-R/SYNAPSE formulas. Do NOT use asynchronous propagation (order-dependent). ALWAYS normalize by fan-out to prevent hub dominance. ALWAYS clamp to [0, 1.0].
  </implementation>
</feature>

<verification>
npx vitest run src/memory/relations.test.ts
</verification>

<success_criteria>
- Failing tests written for all behavior cases listed above
- spreadActivation() passes all tests
- getRelatedMemoriesWithActivation() passes integration-level tests with mock DB
- Edge weights match research spec (UPDATES=0.9/0.9, EXTENDS=0.7/0.5, DERIVES=0.4/0.6)
- Fan-out normalization verified (hub node doesn't dominate)
- Noise sigma=0 gives deterministic results
- All 2-3 TDD commits present
</success_criteria>

<output>
After completion, create `.planning/phases/20-spreading-activation/20-01-SUMMARY.md`
</output>
