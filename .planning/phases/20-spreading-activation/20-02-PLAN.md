---
phase: 20-spreading-activation
plan: 02
type: execute
---

<objective>
Wire spreading activation into the search pipeline, replacing BFS-based getRelatedMemoriesForContext with scored getRelatedMemoriesWithActivation in ScallopMemoryStore.

Purpose: The TDD plan (20-01) implements the algorithm. This plan integrates it into the live search pipeline so related memories returned with search results are ranked by activation score rather than unranked BFS.
Output: ScallopMemoryStore.search() uses activation-based related memory retrieval, with configurable activation parameters and graceful fallback to BFS on error.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-spreading-activation/20-RESEARCH.md
@.planning/phases/20-spreading-activation/20-01-SUMMARY.md

# Key source files:
@src/memory/relations.ts
@src/memory/scallop-store.ts
@src/memory/scallop.test.ts

# Prior integration patterns:
@.planning/phases/18-retrieval-reranking/18-02-SUMMARY.md
@.planning/phases/19-llm-guided-relations/19-02-SUMMARY.md

**Tech stack available:** Vitest, TypeScript
**Established patterns:** Opt-in via constructor options, graceful fallback on failure, integration tests with mock providers
**Constraining decisions:**
- Phase 18-02: Opt-in rerankProvider via constructor — same pattern for activation config
- Phase 19-02: Provider pass-through in constructor — no new class fields for simple config
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace BFS with spreading activation in ScallopMemoryStore search</name>
  <files>src/memory/scallop-store.ts, src/memory/relations.ts</files>
  <action>
    1. In ScallopMemoryStore, change the related memories loop (scallop-store.ts:452-454) to call `this.relationGraph.getRelatedMemoriesWithActivation(result.memory.id)` instead of `getRelatedMemoriesForContext(result.memory.id)`.

    2. Export ActivationConfig from relations.ts so callers can customize if needed.

    3. Add optional `activationConfig` to ScallopMemoryStoreOptions so users can override defaults (maxSteps, decayFactor, noiseSigma etc). Pass it through to getRelatedMemoriesWithActivation calls.

    4. Keep getRelatedMemoriesForContext as a public method on RelationGraph — it serves as the internal fallback in getRelatedMemoriesWithActivation when activation fails.

    Do NOT change the ScallopSearchResult interface — relatedMemories stays as ScallopMemoryEntry[]. The activation scores are internal to the ranking; consumers just get the ordered list.

    Do NOT add activation config to the gateway — defaults are sufficient. Advanced users configure via ScallopMemoryStoreOptions.
  </action>
  <verify>npx vitest run src/memory/scallop.test.ts</verify>
  <done>ScallopMemoryStore.search() calls getRelatedMemoriesWithActivation. Related memories in search results are ordered by activation score. Existing tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Add integration test for activation-based related memories</name>
  <files>src/memory/scallop.test.ts</files>
  <action>
    Add a test in scallop.test.ts that verifies related memories returned from search() are ordered by activation score rather than arbitrary BFS order:

    1. Create a ScallopMemoryStore with test DB
    2. Add a seed memory and several related memories with known relation types and confidences
    3. Manually add relations via the DB (UPDATES with confidence 0.9, EXTENDS with confidence 0.7)
    4. Search for the seed memory
    5. Assert relatedMemories are present and ordered by activation score (UPDATES neighbor before EXTENDS neighbor, since UPDATES has higher edge weight)

    Also add a test verifying that related memories are filtered to isLatest only (existing behavior preserved).

    Follow the existing test patterns in scallop.test.ts — use real ScallopDatabase with in-memory SQLite, mock embedder.
  </action>
  <verify>npx vitest run src/memory/scallop.test.ts</verify>
  <done>Integration tests pass proving activation-based ordering in search results. Related memories ordered by score (UPDATES neighbors ranked higher than EXTENDS). isLatest filtering preserved.</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npx vitest run src/memory/relations.test.ts` — all spreading activation unit tests pass
- [ ] `npx vitest run src/memory/scallop.test.ts` — all integration tests pass including new activation tests
- [ ] `npx vitest run` — full test suite passes, no regressions
- [ ] No TypeScript errors (`npx tsc --noEmit`)
- [ ] getRelatedMemoriesForContext still exists as fallback (not removed)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Search results contain activation-ordered related memories
- Graceful fallback to BFS on any activation failure
- No regressions in existing tests
- Phase 20 complete
</success_criteria>

<output>
After completion, create `.planning/phases/20-spreading-activation/20-02-SUMMARY.md`
</output>
